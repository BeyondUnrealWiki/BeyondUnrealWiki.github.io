<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head lang="en">
	<title>UnrealWiki: Genetic Programming/Nodes</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="stylesheet" type="text/css" media="screen, print"
		href="shared/stylebase.structural.css">	
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/template-default.css">
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/styles.chblue.css">
	<link rel="stylesheet" type="text/css" media="print"
		href="shared/template-default-print.css">
	<!--[if IE 6]>
			<style>
			/* dirty hack for IE6. */
			#quickbar {
				position: absolute;
				}
			</style>
	<![endif]-->
  <link rel="start" href="http://wiki.beyondunreal.com/">
  <link rel="glossary"  href="http://wiki.beyondunreal.com/wiki/Terminology">
  <link rel="help"  href="http://wiki.beyondunreal.com/wiki/Using_The_Wiki">
<script type="text/javascript" src="shared/dhtml.js"></script>
<script type="text/javascript" src="shared/dhtml-menu.js"></script>
<style type="text/css">#dhtml-menu    { background: #eee; padding: 5px 0px; margin-right: -20px; border: 1px solid #888; border-left: 1px solid #ccc; border-top: 1px solid #ccc;  border-right: 1px solid #888; border-bottom: 1px solid #888 }
#dhtml-menu td { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; padding: 1px 10px; cursor: default }
#dhtml-menu a  { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; text-decoration: none }
#dhtml-menu tt { font-family: monospace; font-size: 9pt }
#dhtml-menu-separator { height: 1px; background: red }
#dhtml-menu-anchor { cursor: default }
</style>
<script type="text/javascript" src="shared/expandable.js"></script>
</head>
<body onLoad="menuInit(); document.cookie='page=Genetic_Programming/Nodes; path=/'" class="default">
<div id="scrolling"><!-- contains all except the fixed sidebar -->
<div id="topbar"  class="bar">
	<div class="righthalf">
		<form class="inline" method="post" action="/wiki" enctype="application/x-www-form-urlencoded"><input type="text" name="search"  size="20" /> <input type="submit" name="search" value="search" /></form>
	</div>
	<div class="lefthalf">
		<script type="text/javascript"><!--
			menuAlignRight = false;
		//--></script>
		<span><script type="text/javascript"><!--
 menuWriteAnchor("Quick Navigation") //--></script></span> | <a href="(start).html">Home Page</a> | <a href="recent-changes.html">Recent Changes</a> | <a href="http://wiki.beyondunreal.com/wiki?action=editprefs">Preferences</a>
	</div>
</div>

<div id="content"><!-- contains the title and article -->
	<h1 class='pagetitle'><a href="genetic-programming.html">Genetic Programming</a>/<a href="http://wiki.beyondunreal.com/wiki?back=Genetic+Programming/Nodes">Nodes</a></h1>
	<div class="wiki"><p>First off, read the introduction on <a href="genetic-programming.html">Genetic Programming</a>, and go look at the animated tutorial at <a href="http://www.genetic-programming.com/gpanimatedtutorial.html">[www.genetic-programming.com/gpanimatedtutorial.html]</a> or all of this is all going to be nonsense <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<p>OK, by now you should know that GP uses a tree structure of linked objects to do its 'thinking' these objects are either 'Terminals' (i.e. 'leaves' at the end of the tree branches which return either sensor input or constant values) or 'Functions' which take one or more values and return another.</p>
<p>In my implimentation all nodes take and return floats as arguments so it doesn't matter how much you mix things up, no node gets presented with data it can't cope with.</p>
<p>Here's a simple node that adds together its two inputs:</p>
<pre class="uscript"><span class="uscript-comment">//-----------------------------------------------------------</span>
<span class="uscript-comment">// arithmetic addition function</span>
<span class="uscript-comment">//-----------------------------------------------------------</span>
<span class="uscript-keyword">class</span> GPFplus <span class="uscript-keyword">extends</span> GPnode<span class="uscript-operator">;</span>


<span class="uscript-keyword">function</span> <span class="uscript-type">float</span> evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">return</span><span class="uscript-operator">(</span> children<span class="uscript-operator">[</span><span class="uscript-number">0</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span> <span class="uscript-operator">+</span> children<span class="uscript-operator">[</span><span class="uscript-number">1</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span>

<span class="uscript-keyword">function</span> <span class="uscript-type">string</span> makemytoken<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">return</span><span class="uscript-operator">(</span><span class="uscript-string">"+"</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span>


<span class="uscript-keyword">DefaultProperties</span>
<span class="uscript-operator">{</span>
 childcount<span class="uscript-operator">=</span><span class="uscript-number">2</span>
<span class="uscript-operator">}</span></pre><p>It extends GPnode which is the base class of all the nodes and includes lots of baggage to be explained later, for now just notice that the nodes below it in the parse tree are referenced by the children[] array and that the evaluate method is called on these children in order to get the values that need to be added together. This is the basic magic, all the objects in the tree are linked together and control flows down the branches until something that actually returns a value is evaluated. Some nodes are conditional and branches get evaluated or not depending on conditions... in this way we can produce a program that actually varies its behavior according to conditions, unlike any of the simple examples in the tutorial linked to above which are more like equations than anything we'd call 'code'.</p>
<p>As an example here's evaluate for the 'less than' node:</p>
<pre class="uscript"><span class="uscript-keyword">function</span> <span class="uscript-type">float</span> evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">local</span> <span class="uscript-type">float</span> arg1<span class="uscript-operator">,</span>arg2<span class="uscript-operator">;</span>
  arg1<span class="uscript-operator">=</span>children<span class="uscript-operator">[</span><span class="uscript-number">0</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
  arg2<span class="uscript-operator">=</span>children<span class="uscript-operator">[</span><span class="uscript-number">1</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
  <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>arg1<span class="uscript-operator">&lt;</span>arg2<span class="uscript-operator">)</span> <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>children<span class="uscript-operator">[</span><span class="uscript-number">2</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
  <span class="uscript-keyword">else</span>
    <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>children<span class="uscript-operator">[</span><span class="uscript-number">3</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>Notice how sometimes children[2] gets evaluated and other times it's children[3] that gets to see some action.</p>
<p>Now in order to get any of this to work we need a way of storing the tree so it can be passed around and manipulated, this is where makemytoken() comes in, its job is to return the string representation of that node... pretty simple here but nodes which hold values need something more... here's evaluate and makemytoken for the 'constant' terminal node:</p>
<pre class="uscript"><span class="uscript-keyword">var</span> <span class="uscript-type">float</span> val<span class="uscript-operator">;</span>

<span class="uscript-keyword">function</span> <span class="uscript-type">float</span> evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
    <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>val<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span>

<span class="uscript-keyword">function</span> <span class="uscript-type">string</span> makemytoken<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">return</span><span class="uscript-operator">(</span><span class="uscript-string">"K"</span><span class="uscript-operator">$</span>val<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>As you can see I use the character K to flag a constant and then append the value to is using uscripts really rather useful built in type conversions.</p>
<p>Enough specifics, I hope that conveys the gist, here's the core GPnode code in it's glory:</p>
<pre class="uscript"><span class="uscript-comment">//-----------------------------------------------------------</span>
<span class="uscript-comment">// Genetic Programming parse tree node root class</span>
<span class="uscript-comment">//-----------------------------------------------------------</span>
<span class="uscript-keyword">class</span> GPnode <span class="uscript-keyword">extends</span> Actor<span class="uscript-operator">;</span>


<span class="uscript-keyword">Var</span> <span class="uscript-type">int</span> Childcount<span class="uscript-operator">;</span>
<span class="uscript-keyword">var</span> GPnode children<span class="uscript-operator">[</span><span class="uscript-number">4</span><span class="uscript-operator">]</span><span class="uscript-operator">,</span> parent<span class="uscript-operator">;</span>
<span class="uscript-keyword">var</span> <span class="uscript-type">int</span> childnum<span class="uscript-operator">,</span> depth<span class="uscript-operator">;</span> <span class="uscript-comment">// self = parent.chilren[childnum]</span>
<span class="uscript-keyword">var</span> <span class="uscript-type">string</span> mytoken<span class="uscript-operator">;</span>
<span class="uscript-keyword">var</span> actor mypawn<span class="uscript-operator">;</span>            <span class="uscript-comment">// might not be always be a pawn, hence type = actor for now</span>
<span class="uscript-keyword">var</span> <span class="uscript-keyword">const</span> <span class="uscript-type">string</span> terminators<span class="uscript-operator">,</span> functions<span class="uscript-operator">;</span>
<span class="uscript-keyword">var</span> <span class="uscript-keyword">const</span> <span class="uscript-type">string</span> alltypes<span class="uscript-operator">;</span>


<span class="uscript-keyword">function</span> <span class="uscript-type">float</span> evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>children<span class="uscript-operator">[</span><span class="uscript-number">0</span><span class="uscript-operator">]</span><span class="uscript-operator">.</span>evaluate<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>Variables and a very empty evaluate method.</p>
<p>Now more recursion: this is how the tree gets written out as a string: the node writes it's own token to the string then calls writetostring on its children, those children in turn get their children to write a token to the string and so on... somehow satisfyingly cool to someone like myself who's never been beyond a simple recursive factiorial function before <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<pre class="uscript"><span class="uscript-keyword">function</span> WriteToString<span class="uscript-operator">(</span> <span class="uscript-keyword">out</span> <span class="uscript-type">string</span> genome <span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
 <span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">;</span>
 genome <span class="uscript-operator">=</span> genome<span class="uscript-operator">$</span>MakeMyToken<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
 <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>childcount <span class="uscript-operator">==</span> <span class="uscript-number">0</span><span class="uscript-operator">)</span> <span class="uscript-keyword">return</span><span class="uscript-operator">;</span>
 <span class="uscript-keyword">else</span>
  <span class="uscript-operator">{</span>
    <span class="uscript-keyword">for</span><span class="uscript-operator">(</span>i<span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span>i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>
     <span class="uscript-operator">{</span>
       children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>WriteToString<span class="uscript-operator">(</span>genome<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
     <span class="uscript-operator">}</span>
  <span class="uscript-operator">}</span>
<span class="uscript-operator">}</span>

<span class="uscript-keyword">function</span> <span class="uscript-type">string</span> makemytoken<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
<span class="uscript-comment">//log("makemytoken called on "$self);</span>
<span class="uscript-comment">// null token for base class, make this return the string that represents</span>
<span class="uscript-comment">// any subclass (mostly one char but constant terminators need to write out</span>
<span class="uscript-comment">// their value forinstance)</span>
<span class="uscript-keyword">return</span><span class="uscript-operator">(</span><span class="uscript-string">""</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>Notice also cunning use of an 'out' declaration there so all that needs to be done to create the genome string is simply call WriteToString(s) on the root node of the tree and as if by magic, S gets an encoded version of the object tree written to it.. by now I'm really starting to grock recursion properly and feel like I'm on a run, the elegence of these objects all describing themselves is appealing but in the background I can't help wondering if it all might fall apart somehow... </p>
<p>Doubts or not, this is how most of the functionality has shaped up, simply call a method on the root node and all else follows for various tree manipulation tasks.</p>
<p>Now having written this string we neeed a way of reading it back in and creating an object tree out of it... so let's go all recursive again and we have the imaginatively named:</p>
<pre class="uscript"><span class="uscript-keyword">Function</span> ReadFromString<span class="uscript-operator">(</span> <span class="uscript-keyword">out</span> <span class="uscript-type">string</span> genome<span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">;</span>
  <span class="uscript-keyword">local</span> <span class="uscript-type">string</span> char<span class="uscript-operator">;</span>
  <span class="uscript-keyword">local</span> GPnode node<span class="uscript-operator">;</span>
  <span class="uscript-keyword">for</span> <span class="uscript-operator">(</span> i <span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span> i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>
  <span class="uscript-operator">{</span>
    <span class="uscript-comment">// eat and analyse first (leftmost) char of string</span>
    
    char <span class="uscript-operator">=</span> left<span class="uscript-operator">(</span>genome<span class="uscript-operator">,</span><span class="uscript-number">1</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    genome <span class="uscript-operator">=</span> right<span class="uscript-operator">(</span>genome<span class="uscript-operator">,</span>len<span class="uscript-operator">(</span>genome<span class="uscript-operator">)</span><span class="uscript-operator">-</span><span class="uscript-number">1</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    node <span class="uscript-operator">=</span> addchild<span class="uscript-operator">(</span> char<span class="uscript-operator">,</span>i<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    node<span class="uscript-operator">.</span>ReadFromString<span class="uscript-operator">(</span>genome<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
 <span class="uscript-operator">}</span>
<span class="uscript-operator">}</span></pre><p>So basically you start by spawning a gpnode as the root, feed it the string of gobbledegook generated by writetostring and it reads (and discards) the first character, spawns the appropriate node actor, makes that its first child and passes the rest of the string to it so it can make any children it might need in turn... and so it goes on down the tree.</p>
<p>Addchild is a big switch that takes care of spawning the right sort of node type according to the character token that has been read in:</p>
<pre class="uscript"><span class="uscript-keyword">function</span> gpnode addchild<span class="uscript-operator">(</span><span class="uscript-type">string</span> childtype<span class="uscript-operator">,</span> <span class="uscript-type">int</span> i<span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">local</span> <span class="uscript-keyword">class</span><span class="uscript-operator">&lt;</span>actor<span class="uscript-operator">&gt;</span>  childclass<span class="uscript-operator">;</span>
  <span class="uscript-keyword">local</span> gpnode node<span class="uscript-operator">;</span>

   <span class="uscript-keyword">switch</span><span class="uscript-operator">(</span>childtype<span class="uscript-operator">)</span>
   <span class="uscript-operator">{</span>
    <span class="uscript-comment">// functions first</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"+"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFplus'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"-"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFminus'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"*"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFmultiply'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"%"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFsafeDivide'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"&lt;"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFlessThan'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"Q"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFSqrt'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"N"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFMin'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"X"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFMax'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-comment">// then the terminators</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"R"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFrightTurn'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"L"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPFleftTurn'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"K"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTconstant'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"A"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookAhead'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"B"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookAheadRight'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"C"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookRight'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"D"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookBackRight'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"E"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookBack'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"F"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookBackLeft'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"G"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookLeft'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">case</span> <span class="uscript-string">"H"</span>:
          childclass <span class="uscript-operator">=</span> <span class="uscript-keyword">class</span><span class="uscript-name">'GPTlookAheadLeft'</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
      <span class="uscript-keyword">default</span>:
          log<span class="uscript-operator">(</span> <span class="uscript-string">" *gennode* Uh Oh! unknown token! "</span><span class="uscript-operator">$</span>childtype<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
          <span class="uscript-keyword">break</span><span class="uscript-operator">;</span>
    <span class="uscript-operator">}</span>
   <span class="uscript-comment">// log(" childclass = "$childclass);</span>
    node <span class="uscript-operator">=</span> gpnode<span class="uscript-operator">(</span> spawn<span class="uscript-operator">(</span>childclass<span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">=</span>node<span class="uscript-operator">;</span>
    node<span class="uscript-operator">.</span>mypawn <span class="uscript-operator">=</span> mypawn<span class="uscript-operator">;</span>
    node<span class="uscript-operator">.</span>parent<span class="uscript-operator">=</span><span class="uscript-keyword">self</span><span class="uscript-operator">;</span>
    node<span class="uscript-operator">.</span>childnum<span class="uscript-operator">=</span>i<span class="uscript-operator">;</span>
    node<span class="uscript-operator">.</span>depth<span class="uscript-operator">=</span>depth<span class="uscript-number">+1</span><span class="uscript-operator">;</span>
    <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>node<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>... and the sands of time draw a close to the first session editing this page... things are already a lot clearer in my head thanks to explaining a little to you, dear reader... till the next time I leave you with the remainder of the gpnode class which deals with things like growing random sub trees and other housekeeping. You can view the rest of the classes so far on CVS at the home of UTron on sourcefore here: <a href="https://sourceforge.net/projects/utron/">[8]</a> click on 'browse CVS' and look for classes in the package 'UTron' with names beginning with GP.</p>
<pre class="uscript"><span class="uscript-keyword">function</span> RandomGrow <span class="uscript-operator">(</span> <span class="uscript-type">int</span> depth<span class="uscript-operator">,</span> <span class="uscript-type">int</span> maxdepth <span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
<span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">,</span>j<span class="uscript-operator">,</span>r<span class="uscript-operator">;</span>
<span class="uscript-keyword">local</span> <span class="uscript-type">string</span> char<span class="uscript-operator">;</span>
<span class="uscript-keyword">local</span> GPnode node<span class="uscript-operator">;</span>
  <span class="uscript-comment">//log(" random grow called on "$self@"depth = "$depth);</span>
  <span class="uscript-keyword">for</span> <span class="uscript-operator">(</span> i <span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span> i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>
  <span class="uscript-operator">{</span>
   <span class="uscript-comment">//log(" randomgrow on "$self$"choosing child"$i);</span>
    <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>depth <span class="uscript-operator">==</span> maxdepth<span class="uscript-operator">)</span> <span class="uscript-operator">{</span>
     <span class="uscript-comment">// log("max depth reached");</span>
      char <span class="uscript-operator">=</span> mid<span class="uscript-operator">(</span>terminators<span class="uscript-operator">,</span>rand<span class="uscript-operator">(</span>len<span class="uscript-operator">(</span>terminators<span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">,</span><span class="uscript-number">1</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
  <span class="uscript-comment">//    log("char = "$char);</span>
      node <span class="uscript-operator">=</span> addchild<span class="uscript-operator">(</span>char<span class="uscript-operator">,</span>i<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    <span class="uscript-comment">//  log("new terminator node = "$node);</span>
    <span class="uscript-operator">}</span>
    <span class="uscript-keyword">else</span>
      <span class="uscript-operator">{</span>
       <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>depth <span class="uscript-operator">&lt;</span><span class="uscript-number">4</span><span class="uscript-operator">)</span> char <span class="uscript-operator">=</span> mid<span class="uscript-operator">(</span>functions<span class="uscript-operator">,</span>rand<span class="uscript-operator">(</span>len<span class="uscript-operator">(</span>functions<span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">,</span><span class="uscript-number">1</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span> <span class="uscript-comment">// add a bit of depth to start with for testing</span>
        <span class="uscript-keyword">else</span> char <span class="uscript-operator">=</span> mid<span class="uscript-operator">(</span>alltypes<span class="uscript-operator">,</span>rand<span class="uscript-operator">(</span>len<span class="uscript-operator">(</span>alltypes<span class="uscript-operator">)</span><span class="uscript-operator">)</span><span class="uscript-operator">,</span><span class="uscript-number">1</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
      <span class="uscript-comment">// log("char = "$char);</span>
       node <span class="uscript-operator">=</span> addchild<span class="uscript-operator">(</span> char<span class="uscript-operator">,</span>i<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
      <span class="uscript-comment">// log("new node = "$node);</span>
       <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>node<span class="uscript-operator">.</span>Childcount <span class="uscript-operator">&gt;</span><span class="uscript-number">0</span><span class="uscript-operator">)</span>  node<span class="uscript-operator">.</span>RandomGrow<span class="uscript-operator">(</span>depth<span class="uscript-number">+1</span><span class="uscript-operator">,</span>maxdepth<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
      <span class="uscript-operator">}</span>
  <span class="uscript-operator">}</span>

<span class="uscript-operator">}</span></pre><p>RandomGrow is the function that creates random trees for seeding the initial population and for use in the genetic 'mutation' operation too. Note the plentiful commented out log statments... no more than curious fossils now, they were useful in the extreme when debugging this stuff, a comment after every line is usually a sign that I was tracking down an accessed none... I really should get round to deleting them <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<p>Since there are currently quite a few more terminal nodes defined that there are functions the tree had a habit of being very small most of the time so you'll notice that I make sure that all nodes up to depth 4 are chosen from the set of functions in order to give it a bit of depth... strictly speaking this is biasing what should be a totally random process, the fitness selection and evolution should take care of any runts, so this will probably go once things are fully set up. For now though it's a handy feature for testing.</p>
<p>Sometimes we might need to prune off the branch of a tree before replacing it with something else (like a branch chosen randomly from a tree that performs well at our chosen task, or just another random growth when mutating ) so the prune function recursively destroys nodes below the one on which it is first called.</p>
<p>It still feels a little crufty, that first check on childcount should be redundant really as the parent of any nodes with childcount == 0 will destroy them so that will go soon methinks. In fact a more elegant system would have terminal nodes destroy themselves but at the time I wasn't confident that a function in a node that called that nodes destroy() function  would actually return, so nodes destroy their children instead (after having called prune on child nodes to ensure that their children get destroyed in turn ).</p>
<pre class="uscript"><span class="uscript-keyword">function</span> prune<span class="uscript-operator">(</span><span class="uscript-operator">)</span>    <span class="uscript-comment">// remove objects below this node</span>
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">;</span>
  <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>childcount <span class="uscript-operator">==</span> <span class="uscript-number">0</span> <span class="uscript-operator">)</span> <span class="uscript-keyword">return</span><span class="uscript-operator">;</span>
  <span class="uscript-keyword">else</span>
    <span class="uscript-keyword">for</span><span class="uscript-operator">(</span>i<span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span>i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>
      <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>Childcount<span class="uscript-operator">==</span><span class="uscript-number">0</span><span class="uscript-operator">)</span> children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>Destroy<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
        <span class="uscript-keyword">else</span>
           <span class="uscript-operator">{</span>
             children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>prune<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
             children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>Destroy<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
             children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">=</span><span class="uscript-keyword">none</span><span class="uscript-operator">;</span>
           <span class="uscript-operator">}</span>
  <span class="uscript-keyword">return</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>All of the tree manipulation functions used in creating new trees from an exisiting one need to chose a node at random and then do stuff to it. So the two functions below are used to:</p>
<ol><li>Count the nodes in the tree so that correct range can be used when a random number is generated to pick a node.</li>
<li>Actually return a reference to that random node</li>
</ol>
<pre class="uscript"><span class="uscript-keyword">function</span> countnodes<span class="uscript-operator">(</span><span class="uscript-keyword">out</span> <span class="uscript-type">int</span> nodecount<span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
 <span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">;</span>
 <span class="uscript-comment">//recursively count nodes in tree below this one</span>
 nodecount <span class="uscript-operator">++</span><span class="uscript-operator">;</span>
 <span class="uscript-keyword">for</span> <span class="uscript-operator">(</span>i<span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span>i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>  children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>countnodes<span class="uscript-operator">(</span>nodecount<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
 <span class="uscript-keyword">return</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span>

<span class="uscript-keyword">function</span> gpnode findnode<span class="uscript-operator">(</span><span class="uscript-keyword">out</span> <span class="uscript-type">int</span> nodenum<span class="uscript-operator">)</span> 
<span class="uscript-operator">{</span>
  <span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">;</span>
  <span class="uscript-keyword">local</span> gpnode result<span class="uscript-operator">;</span>
  nodenum <span class="uscript-operator">--</span><span class="uscript-operator">;</span>
  <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>nodenum <span class="uscript-operator">==</span><span class="uscript-number">0</span><span class="uscript-operator">)</span> <span class="uscript-keyword">return</span><span class="uscript-operator">(</span><span class="uscript-keyword">self</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
  <span class="uscript-keyword">else</span>
    <span class="uscript-operator">{</span>
       <span class="uscript-keyword">for</span> <span class="uscript-operator">(</span>i<span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span>i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>
         <span class="uscript-operator">{</span>
           result <span class="uscript-operator">=</span> children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>findnode<span class="uscript-operator">(</span>nodenum<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
           <span class="uscript-keyword">if</span><span class="uscript-operator">(</span>result <span class="uscript-operator">!=</span> <span class="uscript-keyword">none</span><span class="uscript-operator">)</span>
              <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>result<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
         <span class="uscript-operator">}</span>
       <span class="uscript-keyword">return</span><span class="uscript-operator">(</span><span class="uscript-keyword">none</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    <span class="uscript-operator">}</span>
<span class="uscript-operator">}</span></pre><p>last but not least, cloneme() spawns a duplicate of a node and all the tree below it... yet more recursive majick <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<pre class="uscript"><span class="uscript-keyword">function</span> gpnode cloneme<span class="uscript-operator">(</span><span class="uscript-operator">)</span>
<span class="uscript-operator">{</span>
  <span class="uscript-comment">// clone this object, used recursively to duplicate subtrees</span>
  <span class="uscript-keyword">local</span> <span class="uscript-type">int</span> i<span class="uscript-operator">;</span>
  <span class="uscript-keyword">local</span> gpnode newnode<span class="uscript-operator">;</span>

  newnode <span class="uscript-operator">=</span> spawn<span class="uscript-operator">(</span><span class="uscript-keyword">class</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
  <span class="uscript-keyword">for</span><span class="uscript-operator">(</span>i<span class="uscript-operator">=</span><span class="uscript-number">0</span><span class="uscript-operator">;</span>i<span class="uscript-operator">&lt;</span>childcount<span class="uscript-operator">;</span>i<span class="uscript-operator">++</span><span class="uscript-operator">)</span>
    newnode<span class="uscript-operator">.</span>children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span> <span class="uscript-operator">=</span> children<span class="uscript-operator">[</span>i<span class="uscript-operator">]</span><span class="uscript-operator">.</span>cloneme<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    newnode<span class="uscript-operator">.</span>mypawn<span class="uscript-operator">=</span>mypawn<span class="uscript-operator">;</span>
  <span class="uscript-keyword">return</span><span class="uscript-operator">(</span>newnode<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>The most interesting things in the deafult properties are the strings which are used to hold lists of the tokens of the different types of nodes. Add to these when new nodes are made (my current one character per token scheme is nice and simple and I reckon if you find yourself running out of characters as node types undergo runaway expansion you need to think again about how much control you're willing to hand over to the evolution process... stick to minimal building blocks and let complexity sort itself out... another lesson from mr Turing <img alt=":)" src="emoticons/smile.gif" align="middle"> )</p>
<pre class="uscript"><span class="uscript-keyword">DefaultProperties</span>
<span class="uscript-operator">{</span>
DrawType<span class="uscript-operator">=</span>DT_none
bCollideWorld<span class="uscript-operator">=</span><span class="uscript-keyword">false</span>
bCollideActors<span class="uscript-operator">=</span><span class="uscript-keyword">false</span>
bProjtarget<span class="uscript-operator">=</span><span class="uscript-keyword">false</span>
childcount<span class="uscript-operator">=</span><span class="uscript-number">1</span>
Terminators<span class="uscript-operator">=</span><span class="uscript-string">"RLKABCDEFGH"</span>
AllTypes<span class="uscript-operator">=</span><span class="uscript-string">"+-*%&lt;RLKABCDEFGHQNX"</span>
functions<span class="uscript-operator">=</span><span class="uscript-string">"+-*%&lt;QNX"</span>
<span class="uscript-operator">}</span></pre><p>So there you have it, the core node class. But for this to do any good we need a way of storing 'genes' and keeping track of which ones are doing well at our trials, as well as performing the actual 'breeding' and mutation of those high performers. Find the class that does this and further ramblings over at:</p>
<p><a href="genetic-programming-genes.html">Genetic Programming/Genes</a></p>
<h2><a name="0.1"></a>Your Comments Welcome</h2>
<p><em class="em2">DJPaul:</em> Blimey.</p>
<p><em class="em2">Zedsquared</em>  heh!  I'll take that as a good 'Blimey' then <img alt=";)" src="emoticons/wink.gif" align="middle"> food for thought I hope?</p>
<p><em class="em2">Chazums:</em> Strangely enough, just stumbled onto the idea of using this kind of thing for AI today.  Nicely written walk through, makes things clearer in my mind too.</p>
<p><em class="em2">Zedsquared</em> Cheers Chazums, glad my explanations make some sense to you, here's a good link to a page full of such goodies (the whole site is good for AI too) <a href="http://www.gameai.com/genetics.html">[GameAi.com]</a></p>
<script type="text/javascript"><!--
 menuItemAdd("Your Comments Welcome", "#0.1");
 menuWrite() //--></script></div>
</div>

<div id="footer" class="bar">
	<p><form method="post" action="http://wiki.beyondunreal.com/wiki" enctype="application/x-www-form-urlencoded">
<a href="(start).html">Home Page</a> | <a href="genetic-programming.html">Genetic Programming</a> | <a href="recent-changes.html">Recent Changes</a> | <a href="http://wiki.beyondunreal.com/wiki?action=editprefs">Preferences</a><br>
<a href="http://wiki.beyondunreal.com/wiki?action=edit&id=Genetic_Programming/Nodes">Edit text of this page</a> | <a href="http://wiki.beyondunreal.com/wiki?action=history&id=Genetic_Programming/Nodes">View other revisions</a><br>Last edited July 25, 2004 4:54 <a href="http://wiki.beyondunreal.com/wiki?action=browse&diff=1&id=Genetic_Programming/Nodes">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /><br><br><small><a href="http://wiki.beyondunreal.com/wiki/Genetic_Programming/Nodes">Original page</a> &#150; copy created Sat, Jun 23, 2007</small><div></div>
</form>
	</p>
	<p>Gah - a solution with more questions. (EntropicLqd)
</p>
</div>
</div><!-- close of "scrolling" div -->

<div id="quickbar">
	<div id="logo"><a href="http://wiki.beyondunreal.com/"><img src="shared/wikilogo.jpg" width="143" height="100" border="0"></a>
		</div>
	<div class="qbsitename">
		<p>The Unreal Engine Documentation Site</p>
	</div>
	<div class="qbsection">
<p><a href="metatopics.html">Wiki Community</a></p>
<p><a href="category-category.html">Topic Categories</a></p>
<p><a href="/cgi-bin/imageupload.cgi/wiki-ext/imageupload.htt" target="_blank ">Image Uploads</a></p>
<p><a href="http://wiki.beyondunreal.com/wiki?action=random">Random Page</a></p>
<p><a href="recent-changes.html">Recent Changes</a></p>
<p><a href="offline-wiki.html">Offline Wiki</a></p>
</div><div class="qbsection">
<p><a href="unreal-engine.html">Unreal Engine</a></p>
<p><a href="console-commands.html">Console Commands</a></p>
<p><a href="terminology.html">Terminology</a></p>
<p><a href="category-faq.html">FAQs</a></p>
<p><a href="help-desk.html">Help Desk</a></p>
</div><div class="qbsection">
<p><a href="topics-on-mapping.html">Mapping Topics</a></p>
<p><a href="mapping-lessons.html">Mapping Lessons</a></p>
<p><a href="unrealed-3.html">UnrealEd Interface</a></p>
</div><div class="qbsection">
<p><a href="unrealscript.html">UnrealScript Topics</a></p>
<p><a href="unrealscript-lessons.html">UnrealScript Lessons</a></p>
<p><a href="making-mods.html">Making Mods</a></p>
<p><a href="class-tree.html">Class Tree</a></p>
</div><div class="qbsection">
<p><a href="topics-on-modeling.html">Modeling Topics</a></p>
</div><div class="qbsection">
<p><a href="chongqing-page.html">Chongqing Page</a></p>
<p><a href="log-in.html">Log In</a></p></div>
</div>

</body></html>
