<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head lang="en">
	<title>UnrealWiki: Actor/Methods</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="stylesheet" type="text/css" media="screen, print"
		href="shared/stylebase.structural.css">	
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/template-default.css">
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/styles.chblue.css">
	<link rel="stylesheet" type="text/css" media="print"
		href="shared/template-default-print.css">
	<!--[if IE 6]>
			<style>
			/* dirty hack for IE6. */
			#quickbar {
				position: absolute;
				}
			</style>
	<![endif]-->
  <link rel="start" href="http://wiki.beyondunreal.com/">
  <link rel="glossary"  href="http://wiki.beyondunreal.com/wiki/Terminology">
  <link rel="help"  href="http://wiki.beyondunreal.com/wiki/Using_The_Wiki">
<script type="text/javascript" src="shared/dhtml.js"></script>
<script type="text/javascript" src="shared/dhtml-menu.js"></script>
<style type="text/css">#dhtml-menu    { background: #eee; padding: 5px 0px; margin-right: -20px; border: 1px solid #888; border-left: 1px solid #ccc; border-top: 1px solid #ccc;  border-right: 1px solid #888; border-bottom: 1px solid #888 }
#dhtml-menu td { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; padding: 1px 10px; cursor: default }
#dhtml-menu a  { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; text-decoration: none }
#dhtml-menu tt { font-family: monospace; font-size: 9pt }
#dhtml-menu-separator { height: 1px; background: red }
#dhtml-menu-anchor { cursor: default }
</style>
<script type="text/javascript" src="shared/expandable.js"></script>
</head>
<body onLoad="menuInit(); document.cookie='page=Actor/Methods; path=/'" class="default">
<div id="scrolling"><!-- contains all except the fixed sidebar -->
<div id="topbar"  class="bar">
	<div class="righthalf">
		<form class="inline" method="post" action="/wiki" enctype="application/x-www-form-urlencoded"><input type="text" name="search"  size="20" /> <input type="submit" name="search" value="search" /></form>
	</div>
	<div class="lefthalf">
		<script type="text/javascript"><!--
			menuAlignRight = false;
		//--></script>
		<span><script type="text/javascript"><!--
 menuWriteAnchor("Quick Navigation") //--></script></span> | <a href="../index.html">Home Page</a> | <a href="recent-changes.html">Recent Changes</a>
	</div>
</div>

<div id="content"><!-- contains the title and article -->
	<h1 class='pagetitle'><a href="actor.html">Actor</a>/<a href="http://wiki.beyondunreal.com/wiki?back=Actor/Methods">Methods</a></h1>
	<div class="wiki"><div class="classpath"><img src="shared//gameicons/icon-ut2003.png"> <a href="unreal-tournament-2003.html">UT2003</a> :: <a href="object.html">Object</a> &gt;&gt; <a href="actor.html">Actor</a>  (Methods)<br></div>
<h2><a name="0.1"></a>Uncategorized </h2>
<dl><dt>string ConsoleCommand( string Command ) [native]</dt><dd>Execute a console command in the context of the current level and game engine. See <a href="console-commands.html">console commands</a>.</dd><dt>Error( coerce string S ) [native, final]</dt><dd>Handle an error and kill this one actor.</dd><dt>Sleep( float Seconds ) [native, final, latent]</dt><dd>See <a href="latent-function.html">latent function</a>.</dd></dl>
<h2><a name="0.2"></a>Collision </h2>
<dl><dt>SetCollision( optional bool NewColActors, optional bool NewBlockActors, optional bool NewBlockPlayers ) [native, final]</dt><dd>Sets bCollideActors, bBlockActors and bBlockPlayers to the values given by the parameters. bBlockPlayers is obsolete.</dd><dt>bool SetCollisionSize( float NewRadius, float NewHeight ) [native, final]</dt><dd>Sets CollisionRadius and CollisionHeight to the values given by the parameters.</dd></dl>
<h2><a name="0.3"></a>Drawing </h2>
<p>As their names suggest, these functions set the corresponding properties, which can't be changed directly since they are declared as const.</p>
<dl><dt>SetDrawScale( float NewScale ) [native, final]</dt><dt>SetDrawScale3D( vector NewScale3D ) [native, final]</dt><dt>SetStaticMesh( <a href="static-mesh.html">StaticMesh</a> NewStaticMesh ) [native, final]</dt><dt>SetDrawType( EDrawType NewDrawType ) [native, final]</dt></dl>
<h2><a name="0.4"></a>Movement </h2>
<dl><dt>bool Move( vector Delta ) [native, final]</dt><dd>Like SetLocation but parameter is used relative to current location.</dd><dt>bool SetLocation( vector NewLocation ) [native, final]</dt><dd>This function sets the location of the actor it is called on. It will not work on actors with PHYS_Karma or PHYS_KarmaRagdoll. If the actor cannot occupy the new location because it is colliding with an actor that can block it, it will be placed at the nearest valid location. Note that because <a href="terrain.html">Terrain</a> has no "volume" and is just a bent up sheet, the actor may not be moved in this manner when it penetrates <a href="terrain.html">terrain</a>.</dd><dt>bool SetRotation( rotator NewRotation ) [native, final]</dt><dd>This function sets the rotation of the actor it is called on. It will not work on actors with PHYS_Karma or PHYS_KarmaRagdoll. Does this relocate actors with more complex collision hulls if their new rotation causes them to penetrate an actor that can block them?</dd><dt>bool SetRelativeRotation( rotator NewRotation ) [native, final]</dt><dd>Sets the rotation relative to the actor's base.</dd><dt>bool SetRelativeLocation( vector NewLocation ) [native, final]</dt><dd>Sets the rotation reletive to the actor's base.</dd><dt>bool MoveSmooth( vector Delta ) [native, final]</dt><dd></dd><dt>AutonomousPhysics( float DeltaSeconds ) [native, final]</dt><dd></dd></dl>
<h2><a name="0.5"></a>Relations </h2>
<dl><dt>SetBase( <a href="actor.html">Actor</a> NewBase, optional vector NewFloor ) [native, final]</dt><dd>Sets the actor's new base. NewFloor is the optional new floor normal (default is vect(0,0,1)) and it is only used for classes inherited from <a href="pawn.html">Pawn</a>.</dd><dt>SetOwner( <a href="actor.html">Actor</a> NewOwner ) [native, final]</dt><dd>Sets the actor's new owner.</dd></dl>
<h2><a name="0.6"></a>Animation </h2>
<dl><dt>string GetMeshName() [native, final]</dt><dd></dd><dt>bool PlayAnim( name Sequence, optional float Rate, optional float TweenTime, optional int Channel ) [native, final]</dt><dd>Plays one of the animation sequences available for the actor's mesh. Rate is the relative playback speed of the animation sequence. TweenTime is the amount of game time the current animation frame is crossfaded to the start frame of the new animation before the animation sequence actually starts. Channel refers to the channel that this animation should be played on, for blended animations. See <a href="skeletal-mesh.html">Skeletal Mesh</a>. <em class="em1">(What does the function return?)</em> <a href="answer-needed.html">Answer Needed</a></dd><dt>bool LoopAnim( name Sequence, optional float Rate, optional float TweenTime, optional int Channel ) [native, final]</dt><dd>Same as PlayAnim, except that the animation sequence is restarted after it finished. Channel refers to the channel that this animation should be played on, for blended animations. See <a href="skeletal-mesh.html">Skeletal Mesh</a>. <em class="em1">(What does the function return?)</em> <a href="answer-needed.html">Answer Needed</a></dd><dt>bool TweenAnim( name Sequence, float Time, optional int Channel ) [native, final]</dt><dd>Crossfades from the current animation frame to the first frame of the specified animation sequence. Channel refers to the channel that this animation should be played on, for blended animations. See <a href="skeletal-mesh.html">Skeletal Mesh</a>. <em class="em1">(What does the function return?)</em> <a href="answer-needed.html">Answer Needed</a></dd><dt>bool IsAnimating(optional int Channel) [native, final]</dt><dd>Returns whether there's an animation playing in the specified channel.</dd><dt>FinishAnim(optional int Channel) [native, final, latent]</dt><dd>A <a href="latent-function.html">latent function</a> which returns when the animation sequence in the specified channel has reached its last frame.</dd><dt>bool HasAnim( name Sequence ) [native, final]</dt><dd>Returns whether the actor's current mesh has an animation sequence with the specified name.</dd><dt>StopAnimating( optional bool ClearAllButBase ) [native, final]</dt><dd>Immediately stops the animation(s) the actor is currently playing. <em class="em1">(What does ClearAllButBase do?)</em> <a href="answer-needed.html">Answer Needed</a></dd><dt>FreezeAnimAt( float Time, optional int Channel) [native, final]</dt><dd>Freezes the specified channel's animation. <em class="em1">(How exactly does this work?)</em> <a href="answer-needed.html">Answer Needed</a></dd><dt>SetAnimFrame( float Time, optional int Channel, optional int UnitFlag ) [native, final]</dt><dd>Sets an animation in a certain channel to the specified time index. If the UnitFlag is 0 then the time value ranges from 0 to 1, 1 being the end of the animation (last frame) and 0 being the beginning (first frame). If the UnitFlag is 1 then the time is the frame that you want it to go to.</dd><dt>bool IsTweening(int Channel) [native, final]</dt><dd>Returns whether the specified channel is currently fading in (tweening to) a new animation sequence.</dd><dt>AnimStopLooping(optional int Channel) [native, final]</dt><dd>Prevents an animation sequence from starting over by itself once it has reached its last frame.</dd></dl>
<h3><a name="0.6.1"></a>Animation Notifications </h3>
<dl><dt>AnimEnd( int Channel ) [event]</dt><dd>Notification that the current animation has ended.  Allows an object to wait for animation completion before proceeding with other activities.</dd><dt>EnableChannelNotify ( int Channel, int Switch ) [native, final]</dt><dd></dd><dt>int GetNotifyChannel() [native, final]</dt><dd></dd></dl>
<h3><a name="0.6.2"></a>Skeletal Animation </h3>
<dl><dt>LinkSkelAnim( MeshAnimation<a href="http://wiki.beyondunreal.com/wiki?action=edit&id=MeshAnimation&referrerid=Actor/Methods">?</a> Anim, optional <a href="mesh.html">Mesh</a> NewMesh ) [simulated, native, final]</dt><dd>Links a new animation set and mesh to the actor.</dd><dt>LinkMesh( <a href="mesh.html">Mesh</a> NewMesh, optional bool bKeepAnim ) [simulated, native, final]</dt><dd>Loads a new <a href="mesh.html">mesh</a> for the actor and optionally keeps the animation set of the previous mesh.</dd><dt>BoneRefresh() [native, final]</dt><dd>Updates the bone coords.</dd><dt>AnimBlendParams( int Stage, optional float BlendAlpha, optional float InTime, optional float OutTime, optional name BoneName, optional bool bGlobalPose) [native, final]</dt><dd>See <span class="interwiki"><img 
        alt="udntech logo"
        title="udntech"
        src="shared//InterWiki-udntech.png">&nbsp;<a href="https://docs.unrealengine.com/udk/Two/SkeletalBlending.html">SkeletalBlending</a></span>.</dd><dt>AnimBlendToAlpha( int Stage, float TargetAlpha, float TimeInterval ) [native, final]</dt><dd></dd><dt>coords GetBoneCoords( name BoneName ) [native, final]</dt><dd></dd><dt>rotator GetBoneRotation( name BoneName, optional int Space ) [native, final]</dt><dd></dd><dt>vector GetRootLocation() [native, final]</dt><dd></dd><dt>rotator GetRootRotation() [native, final]</dt><dd></dd><dt>vector GetRootLocationDelta() [native, final]</dt><dd></dd><dt>rotator GetRootRotationDelta() [native, final]</dt><dd></dd><dt>bool AttachToBone( <a href="actor.html">Actor</a> Attachment, name BoneName ) [native, final]</dt><dd>Attaches the actor to the bone/socket alias using the attachment offset/rotation defined within the socket.</dd><dt>bool DetachFromBone( <a href="actor.html">Actor</a> Attachment ) [native, final]</dt><dd></dd><dt>LockRootMotion( int Lock ) [native, final]</dt><dd></dd><dt>SetBoneScale( int Slot, optional float BoneScale, optional name BoneName ) [native, final]</dt><dd>Scales the specified bone, overriding any other bone scaling associated with the specified slot. Not sure of the rationale in exposing the slots.</dd><dt>SetBoneDirection( name BoneName, rotator BoneTurn, optional vector BoneTrans, optional float Alpha, optional int Space ) [native, final]</dt><dd></dd><dt>SetBoneLocation( name BoneName, optional vector BoneTrans, optional float Alpha ) [native, final]</dt><dd></dd><dt>SetBoneRotation( name BoneName, optional rotator BoneTurn, optional int Space, optional float Alpha ) [native, final, simulated]</dt><dd></dd><dt>GetAnimParams( int Channel, out name OutSeqName, out float OutAnimFrame, out float OutAnimRate ) [native, final]</dt><dd></dd><dt>bool AnimIsInGroup( int Channel, name GroupName ) [native, final]</dt><dd></dd><dt>Name GetClosestBone( Vector loc, Vector ray, out float boneDist, optional Name BiasBone, optional float BiasDistance ) [native, final]</dt><dd>Returns the closest socket alias, not the bone (UT2004).</dd></dl>
<h2><a name="0.7"></a>URLs</h2>
<dl><dt>UpdateURL( String NewOption, String NewValue, bool bSaveDefault ) [native, final]</dt><dd>Updates an URL option and optionally saves it as default URL option.</dd><dt>string GetUrlOption( String Option ) [native, final]</dt><dd>Returns the value of an URL option.</dd></dl>
<h2><a name="0.8"></a>Rendering </h2>
<dl><dt>plane GetRenderBoundingSphere() [native, final]</dt><dd>Returns a plane struct which represents a sphere surrounding the actor. (X, Y, Z represent the center, W the radius)</dd><dt>DrawDebugLine( vector LineStart, vector LineEnd, byte R, byte G, byte B) [native, final]</dt><dd>SLOW! Use for debugging only!</dd></dl>
<h2><a name="0.9"></a>Physics </h2>
<dl><dt>DebugClock() [native, final]</dt><dd></dd><dt>DebugUnclock() [native, final]</dt><dd></dd><dt>FinishInterpolation() [native, final, latent]</dt><dd><a href="latent-function.html">Latent function</a>, which returns when the actor has finished following its assigned interpolation path.</dd><dt>SetPhysics( EPhysics newPhysics ) [native, final]</dt><dd>Sets a new physics mode.</dd><dt>OnlyAffectPawns( bool B ) [native, final]</dt><dd></dd></dl>
<h3><a name="0.9.1"></a>Karma </h3>
<p>Note that SimParams take affect until you quit the game! Make sure you reset them to defaults when leaving your mod etc.</p>
<dl><dt>KGetSimParams( out KSimParams SimParams ) [native, final]</dt><dd></dd><dt>KSetSimParams( KSimParams SimParams ) [native, final]</dt><dd></dd><dt>quat KGetRBQuaternion() [native, final]</dt><dd></dd><dt>KGetRigidBodyState( out KRigidBodyState RBstate ) [native, final]</dt><dd>Returns the current Karma state of the actor in the RBstate variable</dd><dt>KDrawRigidBodyState( KRigidBodyState RBState, bool AltColour ) [native, final]</dt><dd>SLOW! Use for debugging only!</dd><dt>vector KRBVecToVector( KRBVec RBvec ) [native, final]</dt><dd>Returns a vector created from the Karma KRBVec</dd><dt>KRBVec KRBVecFromVector( vector v ) [native, final]</dt><dd>Returns a Karma KBBVec created from the regular Unreal vector</dd><dt>KSetMass( float mass ) [native, final]</dt><dd>Sets the Karma KMass property of an Actor</dd><dt>float KGetMass() [native, final]</dt><dd>Returns the Karma KMass</dd><dt>KSetInertiaTensor( vector it1, vector it2 ) [native, final]</dt><dd>Set inertia tensor assuming a mass of 1. Scaled by mass internally to calculate actual inertia tensor.</dd><dt>KGetInertiaTensor( out vector it1, out vector it2 ) [native, final]</dt><dd></dd><dt>KSetDampingProps( float lindamp, float angdamp ) [native, final]</dt><dd></dd><dt>KGetDampingProps( out float lindamp, out float angdamp ) [native, final]</dt><dd></dd><dt>KSetFriction( float friction ) [native, final]</dt><dd>Sets the Karma Friction property</dd><dt>float KGetFriction() [native, final]</dt><dd>Returns the Karma Friction property</dd><dt>KSetRestitution( float rest ) [native, final]</dt><dd>Sets the Karma Restitution (Bounciness) property</dd><dt>float KGetRestitution() [native, final]</dt><dd>Returns the Karma Restitution property</dd><dt>KSetCOMOffset( vector offset ) [native, final]</dt><dd></dd><dt>KGetCOMOffset( out vector offset ) [native, final]</dt><dd></dd><dt>KGetCOMPosition( out vector pos ) [native, final]</dt><dd>Get actual position of actors COM in world space.</dd><dt>KSetImpactThreshold( float thresh ) [native, final]</dt><dd>Sets the threshold for velocity at which a moving Karma actor must strike something before it's KImpact() event is called</dd><dt>float KGetImpactThreshold() [native, final]</dt><dd>Returns the Impact Threshhold</dd><dt>KWake() [native, final]</dt><dd>Begins Karma simulation</dd><dt>bool KIsAwake() [native, final]</dt><dd>Returns true if Karma is simulating for this Actor</dd><dt>KAddImpulse( vector Impulse, vector Position, optional name BoneName ) [native, final]</dt><dd>Adds a Karma impulse to the actor from Position, applying to BoneName</dd><dt>KSetStayUpright( bool stayUpright, bool allowRotate ) [native, final]</dt><dd>Sets the KStayUpright poperty</dd><dt>KSetBlockKarma( bool newBlock ) [native, final]</dt><dd>Sets the actor to block Karma</dd><dt>KSetActorGravScale( float ActorGravScale ) [native, final]</dt><dd>Sets the Karma GravScale</dd><dt>float KGetActorGravScale() [native, final]</dt><dd>Returns the Karma GravScale</dd><dt>KDisableCollision( <a href="actor.html">Actor</a> Other ) [native, final]</dt><dd>Disable Karma contact generation between this actor, and another actor.  Collision is on by default.</dd><dt>KEnableCollision( <a href="actor.html">Actor</a> Other ) [native, final]</dt><dd>Enable Karma contact generation between this actor, and another actor.  Collision is on by default.</dd></dl>
<p>The Karma functions are discussed in more detail on the <a href="karma-functions-and-events.html">Karma Functions And Events</a> page.</p>
<h3><a name="0.9.2"></a>Karma Ragdoll </h3>
<dl><dt>KSetSkelVel( vector Velocity, optional vector AngVelocity, optional bool AddToCurrent ) [native, final]</dt><dd></dd><dt>float KGetSkelMass() [native, final]</dt><dd></dd><dt>KFreezeRagdoll() [native, final]</dt><dd></dd><dt>KAddBoneLifter( name BoneName, InterpCurve LiftVel, float LateralFriction, InterpCurve Softness ) [native, final]</dt><dd>Note you MUST turn collision off (KSetBlockKarma) before using bone lifters!</dd><dt>KRemoveLifterFromBone( name BoneName ) [native, final]</dt><dd></dd><dt>KRemoveAllBoneLifters() [native, final]</dt><dd>Used for only allowing a fixed maximum number of ragdolls in action.</dd><dt>KMakeRagdollAvailable() [native, final]</dt><dd></dd><dt>bool KIsRagdollAvailable() [native, final]</dt><dd></dd></dl>
<h3><a name="0.9.3"></a>Karma Events</h3>
<dl><dt>KImpact( <a href="actor.html">Actor</a> other, vector pos, vector impactVel, vector impactNorm) [event]</dt><dd>called when <a href="karma.html">Karma</a> actor hits with impact velocity over KImpactThreshold </dd><dt>KVelDropBelow() [event]</dt><dd>called when karma actor's velocity drops below KVelDropBelowThreshold</dd><dt>KSkelConvulse() [event]</dt><dd>called when a ragdoll convulses (see KarmaParamsSkel)</dd><dt>KApplyForce( out vector Force, out vector Torque ) [event]</dt><dd>called just before sim to allow user to apply force (location movement) and torque (rotation movement) to the actor.  You should ONLY put numbers into Force and Torque during this event!!!!</dd><dt>bool KUpdateState(out KRigidBodyState newState) [event]</dt><dd>This is called from inside C++ Karma physics code at the appropriate time to update state of Karma rigid body. If you return true, newState will be set into the rigid body. Return false and it will do nothing.<br>It seems this is only called on subclasses of <a href="kactor.html">KActor</a>, <a href="kvehicle.html">KVehicle</a> and <a href="svehicle.html">SVehicle</a>.</dd></dl>
<p>The Karma functions are discussed in more detail on the <a href="karma-functions-and-events.html">Karma Functions And Events</a> page.</p>
<h2><a name="0.10"></a>Optimization</h2>
<dl><dt>Clock( out float time ) [native, final]</dt><dd>This is called at the beginning of a section of code to be timed.  The variable time does not need to be initialized.  See <a href="code-optimization.html">Code Optimization</a> for a code sample.</dd><dt>UnClock( out float time ) [native, final]</dt><dd>This is called at the end of a section of code to be timed passing in the same time variable supplied to Clock.  See <a href="code-optimization.html">Code Optimization</a> for a code sample.</dd><dt>CyclesToSeconds( int cycles) [native, final]</dt><dd>Available for Deus Ex. Converts the cycles created by Clock/UnClock to seconds.</dd></dl>
<h2><a name="0.11"></a>Timing </h2>
<dl><dt>SetTimer( float NewTimerRate, bool bLoop ) [native, final]</dt><dd>Causes Timer() events every NewTimerRate seconds. If bLoop is true, causes <tt>Timer()</tt> events every NewTimerRate seconds. Otherwise, causes <tt>Timer()</tt> to be called once in NewTimerRate seconds. <code>SetTimer(0.0, False);</code> stops the timer. Actors with bStatic true do not get ticked, and as such the timer will not function if bStatic is true.</dd></dl>
<h2><a name="0.12"></a>Music </h2>
<dl><dt>int PlayMusic( string Song, float FadeInTime ) [native, final]</dt><dd>Plays a song name, given a FadeInTime, returns a SongHandle.</dd><dt>StopMusic( int SongHandle, float FadeOutTime ) [native, final]</dt><dd>Stops the specified SongHandle (as given to you by PlayMusic)</dd><dt>StopAllMusic( float FadeOutTime ) [native, final]</dt><dd>Stops all music</dd></dl>
<h2><a name="0.13"></a>Engine notification functions </h2>
<dl><dt>Destroyed() [event]</dt><dd>called when an actor is destroyed. See <a href="destroying-objects.html">Destroying Objects</a>.</dd><dt>GainedChild( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called when another actor sets this actor as its Owner through SetOwner() or Spawn().</dd><dt>LostChild( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called when another actor is no longer owned by this actor. Ownership was changed through SetOwner() or the other actor was destroyed.</dd><dt>Tick( float DeltaTime ) [event]</dt><dd>Called when time passes if this actor isn't bStatic. <em class="em1">DeltaTime</em> is the time in seconds that has passed since the last tick. Child actors are ticket after their owners have been ticked. Temporarily toggle with Enable('Tick'), Disable('Tick'). See <a href="probe-function.html">Probe Function</a>.</dd><dt>Timer() [event]</dt><dd>When a timer has been started with SetTimer(), this function is executed when the amount of time that was specified in SetTimer has passed. Like Tick() this event will only be called when the actor is not static and has not been disabled via Disable('Timer'). See <a href="probe-function.html">Probe Function</a>.</dd><dt>PostNetReceive() [event]</dt><dd>If bNetNotify is True, this event is called when the actor receives an update to any variable through replication. See <a href="replication.html">Replication</a>.</dd><dt>TornOff() [event]</dt><dd>Networking - called on client when actor is torn off. (bTearOff==true)</dd></dl>
<h3><a name="0.13.1"></a>Triggers </h3>
<dl><dt>Trigger( <a href="actor.html">Actor</a> Other, <a href="pawn.html">Pawn</a> EventInstigator ) [event]</dt><dd>Called when this actor's <a href="event.html">Event</a> is triggered.</dd><dt>UnTrigger( <a href="actor.html">Actor</a> Other, <a href="pawn.html">Pawn</a> EventInstigator ) [event]</dt><dd>Called when this actor's <a href="event.html">Event</a> is untriggered.</dd><dt>BeginEvent() [event]</dt><dd></dd><dt>EndEvent() [event]</dt><dd></dd></dl>
<h3><a name="0.13.2"></a>Physics &amp; world interaction </h3>
<dl><dt>HitWall( vector HitNormal, <a href="actor.html">Actor</a> HitWall ) [event]</dt><dd>Called when the actor can collide with world geometry and just hit a wall.</dd><dt>Falling() [event]</dt><dd>Called with PHYS_Falling when the actor starts to fall.</dd><dt>Landed( vector HitNormal ) [event]</dt><dd>Called when the actor is no longer falling. If you want to receive HitWall() instead of Landed() set bBounce=True.</dd><dt>ZoneChange( <a href="zoneinfo.html">ZoneInfo</a> NewZone ) [event]</dt><dd>Called when the actor's zone is about to change to NewZone.</dd><dt>PhysicsVolumeChange( <a href="physicsvolume.html">PhysicsVolume</a> NewVolume ) [event]</dt><dd>Called when the actor's PhysicsVolume is about to change to NewVolume.</dd><dt>Touch( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called when the actor's collision hull is touching another actor's collision hull.</dd><dt>PostTouch( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>called for PendingTouch actor after physics completes</dd><dt>UnTouch( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called when the actor's collision hull no longer touches another actor's collision hull.</dd><dt>Bump( <a href="actor.html">Actor</a> Other ) [event]</dt><dd></dd><dt>BaseChange() [event]</dt><dd>Called when the actor's base has changed.</dd><dt>Attach( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called by <em class="em1">SetBase()</em> to notify an actor that another actor <em class="em1">Other</em> has been attached to it.</dd><dt>Detach( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called by <em class="em1">SetBase()</em> to notify an actor that a previously attached actor <em class="em1">Other</em> has been detached from it.</dd><dt>Actor SpecialHandling( <a href="pawn.html">Pawn</a> Other) [event]</dt><dd></dd><dt>bool EncroachingOn( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>Called when this actor's collision hull intersects a blocking actor's collision hull. Returns whether this actor is "encroaching" on the other actor.</dd><dt>EncroachedBy( <a href="actor.html">Actor</a> Other ) [event]</dt><dd>When another actor has determined that it "encroaches" this actor, this event is called.</dd><dt>FinishedInterpolation() [event]</dt><dd>The actor has finished folowing its assigned interpolation path.</dd><dt>EndedRotation() [event]</dt><dd>Called when rotation completes.</dd><dt>UsedBy( <a href="pawn.html">Pawn</a> user ) [event]</dt><dd>Called if this Actor was touching a Pawn who pressed Use.</dd><dt>FellOutOfWorld( eKillZType KillType ) [simulated, event]</dt><dd>Called when the actor fell below the current zone's KillZ height. By default this sets physics to none and destroys the actor.</dd><dt><a href="actor.html">Actor</a> Trace( out vector HitLocation, out vector HitNormal, vector TraceEnd, optional vector TraceStart, optional bool bTraceActors, optional vector Extent, optional out <a href="material.html">Material</a> Material ) [native, final]</dt><dd>This traces a path to find what it collides with first. The line will be traced starting at TraceStart and ending at TraceEnd. If bTraceActors is true, actors will be considered for the tracing, otherwise only pieces of the world (terrain, staticmeshactors, BSP) will be considered for collision. When the trace hits something, HitLocation and HitNormal will be set to contain the location and normal of the impact. If specified, the material of the surface hit can also be returned. If an Extent is specified, you can have the trace have "width." It will have a box of the size specified as a vector (corner to corner) as the "thickness" of the trace. Note that traces are not very fast, so should be avoided or kept to a minimum where possible. Note that if you want actors to be considered for traces they must be able to block the trace, either by bCollideActors, or easier with bBlockZeroExtentTraces or bBlockNonZeroExtentTraces if your trace uses extents. See Trace<a href="http://wiki.beyondunreal.com/wiki?action=edit&id=Trace&referrerid=Actor/Methods">?</a> for more.</dd></dl>
<p><em class="em2">Foxpaw:</em> Can someone elaborate on the extents of a trace? Specifically, is the box aligned on the world axes or along the trace? IE, does the X of the extents point "foreward" along the trace, with Y and Z perpindicular to the trace, or do they define a box in the world coordinate system that gets "dragged along" the length of the trace?</p>
<p><em class="em2">Foxpaw:</em> Tracing doesn't seem to interact properly with terrain if you use extents. I have been able to get zero extent traces to hit terrain, but not extent traces.</p>
<p><em class="em2">Devi:</em> In theory the extent vector gets interpreted as a world aligned rectangular prism when doing Terrain checks, when it's testing versus actors it gets interpreted as a vertical cylinder. The cylinder collision type can go a bit weird if the X and Y values in the extent vector don't match...</p>
<dl><dt>bool FastTrace( vector TraceEnd, optional vector TraceStart ) [native, final]</dt><dd>Similar to trace. Returns true if there is a clear path between the two points, false if the trace is blocked by world geometry. It will pass right through anything that is not set as world geometry.</dd><dt><a href="actor.html">Actor</a> Spawn( class&lt;<a href="actor.html">Actor</a>&gt; SpawnClass, optional <a href="actor.html">Actor</a> SpawnOwner, optional name SpawnTag, optional vector SpawnLocation, optional rotator SpawnRotation ) [native, final]</dt><dd>Spawn an actor. Returns an actor of the specified class, not of class Actor (this is hardcoded in the compiler). Returns None if the actor could not be spawned (either the actor wouldn't fit in the specified location, or the actor list is full). Defaults to spawning at the spawner's location. See <a href="chain-of-events-when-spawni.html">Chain Of Events When Spawning Actors</a>.</dd><dt>bool Destroy() [native, final]</dt><dd>Destroy this actor. Returns true if destroyed, false if indestructable. Destruction is latent. It occurs at the end of the tick. See <a href="destroying-objects.html">Destroying Objects</a>.</dd></dl>
<h3><a name="0.13.3"></a>Damage &amp; Kills </h3>
<dl><dt>KilledBy( <a href="pawn.html">Pawn</a> EventInstigator ) [event]</dt><dd>This actor was "killed" by a <a href="pawn.html">Pawn</a>.</dd><dt>TakeDamage( int Damage, <a href="pawn.html">Pawn</a> EventInstigator, vector HitLocation, vector Momentum, class&lt;<a href="damagetype.html">DamageType</a>&gt; DamageType ) [event]</dt><dd>Called when the actor is taking damage.</dd></dl>
<h2><a name="0.14"></a>Sound </h2>
<dl><dt>PlaySound( <a href="sound.html">Sound</a> Sound, optional ESoundSlot Slot, optional float Volume, optional bool bNoOverride, optional float Radius, optional float Pitch, optional bool Attenuate ) [native, final]</dt><dd>Play a sound effect. If called from a simulated function or on a client, the sound is propagated only to the local player, i.e. only he will hear the sound. If called from a non-simulated function on the server, the sound is propagated to all players. (They will hear it as long as they are in range.)</dd><dt>PlayOwnedSound( <a href="sound.html">Sound</a> Sound, optional ESoundSlot Slot, optional float Volume, optional bool bNoOverride, optional float Radius, optional float Pitch, optional bool Attenuate ) [native, simulated, final]</dt><dd>Play a sound effect. On clients this is function behaves identical to PlaySound. If called on the server the sound os propagated to all players but the remote owner. It will be propagated to a local owner, though.</dd><dt>DemoPlaySound( <a href="sound.html">Sound</a> Sound, optional ESoundSlot Slot, optional float Volume, optional bool bNoOverride, optional float Radius, optional float Pitch, optional bool Attenuate ) [native, simulated, event]</dt><dd></dd><dt>float GetSoundDuration( <a href="sound.html">Sound</a> Sound ) [native, final]</dt><dd>Get a sound duration in seconds. (not affected by Level.TimeDilation)</dd></dl>
<h2><a name="0.15"></a>Force Feedback </h2>
<dl><dt>PlayFeedbackEffect( String EffectName ) [native, final]</dt><dd></dd><dt>StopFeedbackEffect( optional String EffectName ) [native, final]</dt><dd>Pass no parameter or "" to stop all.</dd><dt>bool ForceFeedbackSupported( optional bool Enable ) [native, final]</dt><dd></dd></dl>
<h2><a name="0.16"></a>AI </h2>
<dl><dt>MakeNoise( float Loudness ) [native, final]</dt><dd>Inform other creatures that you've made a noise they might hear (they are sent a HearNoise message). Senders of MakeNoise should have an instigator if they are not pawns. The noise is blocked by walls (only tested BSP, not SM)</dd></dl>
<p><em class="em2">Foxpaw:</em> This probrably does a "FastTrace" and will be blocked by any object that is set as being world geometry. I haven't tested that either though.</p>
<p><em class="em2">Wormbo:</em> It's not simply a trace. it also takes into account that noise travels around corners etc. by doing path (<a href="navigationpoint.html">NavigationPoint</a>.bPropagatesSound) and zone checks.</p>
<dl><dt>bool PlayerCanSeeMe() [native, final]</dt><dd>Returns true if any player (server) or the local player (standalone or client) has a line of sight to actor's location.  <em class="em2">Note:</em> If the Actor in question is set to bHidden=True, this will always return false.</dd><dt>vector SuggestFallVelocity( vector Destination, vector Start, float MaxZ, float MaxXYSpeed ) [native, final]</dt><dd></dd></dl>
<h2><a name="0.17"></a>??? </h2>
<dl><dt>bool PreTeleport( <a href="teleporter.html">Teleporter</a> InTeleporter ) [event]</dt><dd>Called when an actor is about to be moved by a teleporter</dd><dt>PostTeleport( <a href="teleporter.html">Teleporter</a> OutTeleporter ) [event]</dt><dd>Called when an actor exits a teleporter</dd></dl>
<h2><a name="0.18"></a>Disk access </h2>
<dl><dt>string GetMapName( string NameEnding, string MapName, int Dir ) [native, final]</dt><dd></dd><dt>GetNextSkin( string Prefix, string CurrentSkin, int Dir, out string SkinName, out string SkinDesc ) [native, final]</dt><dd></dd><dt>string GetURLMap() [native, final]</dt><dd></dd><dt>string GetNextInt( string ClassName, int Num ) [native, final]</dt><dd></dd><dt>GetNextIntDesc( string ClassName, int Num, out string Entry, out string Description ) [native, final]</dt><dd></dd><dt>bool GetCacheEntry( int Num, out string GUID, out string Filename ) [native, final]</dt><dd></dd><dt>bool MoveCacheEntry( string GUID, optional string NewFilename ) [native, final]</dt><dd></dd></dl>
<h2><a name="0.19"></a>Iterator functions </h2>
<p><a href="iterator.html">Iterator</a> functions for dealing with sets of actors.</p>
<dl><dt>AllActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, optional name MatchTag ) [native, final, iterator]</dt><dd>Avoid using AllActors() too often as it iterates through the whole actor list and is therefore slow.</dd><dt>DynamicActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, optional name MatchTag ) [native, final, iterator]</dt><dd>Only iterates through the non-static actors on the list (still relatively slow, but much better than AllActors).  This should be used in most cases and replaces AllActors in most of Epic's game code.</dd><dt>ChildActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor ) [native, final, iterator]</dt><dd>Returns all actors owned by this actor.  Slow like AllActors().</dd><dt>BasedActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor ) [native, final, iterator]</dt><dd>Returns all actors based on the current actor (slow, like AllActors).</dd><dt>TouchingActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor ) [native, final, iterator]</dt><dd>Returns all actors touching the current actor (fast). Actors that are attached are ignored.</dd><dt>TraceActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent ) [native, final, iterator]</dt><dd>TraceActors() return all actors along a traced line.  Reasonably fast (like any trace).</dd><dt>RadiusActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, float Radius, optional vector Loc ) [native, final, iterator]</dt><dd>Returns all actors within a give radius.  Slow like AllActors().  Use CollidingActors() or VisibleCollidingActors() instead if desired actor types are visible (not bHidden) and in the collision hash (bCollideActors is true).</dd><dt>VisibleActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, optional float Radius, optional vector Loc ) [native, final, iterator]</dt><dd>Returns all visible actors within a radius.  Slow like AllActors().  Use VisibleCollidingActors() instead if desired actor types are in the collision hash (bCollideActors is true).</dd><dt>VisibleCollidingActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, float Radius, optional vector Loc, optional bool bIgnoreHidden ) [native, final, iterator]</dt><dd>VisibleCollidingActors() returns visible (not bHidden) colliding (bCollideActors==true) actors within a certain radius. Much faster than AllActors() since it uses the collision hash.</dd><dt>CollidingActors( class&lt;<a href="actor.html">Actor</a>&gt; BaseClass, out <a href="actor.html">Actor</a> Actor, float Radius, optional vector Loc ) [native, final, iterator]</dt><dd>Returns colliding (bCollideActors==true) actors within a certain radius. Much faster than AllActors() for reasonably small radii since it uses the collision hash.</dd></dl>
<h2><a name="0.20"></a>Scripted Actor functions </h2>
<dl><dt>BecomeViewTarget()</dt><dd>Called by PlayerController when this actor becomes its ViewTarget.</dd><dt>BroadcastLocalizedMessage( class&lt;<a href="localmessage.html">LocalMessage</a>&gt; MessageClass, optional int Switch, optional <a href="playerreplicationinfo.html">PlayerReplicationInfo</a> RelatedPRI_1, optional <a href="playerreplicationinfo.html">PlayerReplicationInfo</a> RelatedPRI_2, optional <a href="object.html">Object</a> OptionalObject ) [event]</dt><dd>Broadcast a localized message to all players. Most message deal with 0 to 2 related PRIs. The LocalMessage class defines how the PRI's and optional actor are used.</dd><dt>DisplayDebug( <a href="canvas.html">Canvas</a> Canvas, out float YL, out float YPos ) [simulated]</dt><dd>lists important actor variable on canvas.  HUD will call DisplayDebug() on the current ViewTarget when the ShowDebug exec is used.</dd><dt>HurtRadius( float DamageAmount, float DamageRadius, class&lt;DamageType&gt; DamageType, float Momentum, vector HitLocation ) [simulated, final]</dt><dd>Hurt locally authoritative actors within the radius.</dd><dt>MatchStarting()</dt><dd>Called when gameplay actually starts.</dd><dt>PlayTeleportEffect( bool bOut, bool bSound )</dt><dd></dd><dt>PreBeginPlay() [event]</dt><dd>Called immediately before gameplay begins. See <a href="chain-of-events-at-level-st.html">chain of events at level startup</a> and <a href="chain-of-events-when-spawni.html">chain of events when spawning actors</a>.</dd><dt>BeginPlay() [event]</dt><dd>Called when gameplay begins. See <a href="chain-of-events-at-level-st.html">chain of events at level startup</a> and <a href="chain-of-events-when-spawni.html">chain of events when spawning actors</a>.</dd><dt>PostBeginPlay() [event]</dt><dd>Called immediately after gameplay begins. See <a href="chain-of-events-at-level-st.html">chain of events at level startup</a> and <a href="chain-of-events-when-spawni.html">chain of events when spawning actors</a>.</dd><dt>PostNetBeginPlay() [event]</dt><dd>called after PostBeginPlay.  On a net client, PostNetBeginPlay() is spawned after replicated variables have been initialized to their replicated values. See <a href="chain-of-events-at-level-st.html">chain of events at level startup</a> and <a href="chain-of-events-when-spawni.html">chain of events when spawning actors</a>.</dd><dt>RenderOverlays( <a href="canvas.html">Canvas</a> Canvas )</dt><dd>Called by player's hud to request drawing of actor-specific overlays onto canvas. Called every frame. Whatever is drawn on the canvas here only lasts for the current frame.<br><em class="em2">Note:</em> This function has to be called explicitly by another canvas drawing function, it's <em class="em1">not</em> called automatically for all actors.</dd><dt>RenderTexture( <a href="scriptedtexture.html">ScriptedTexture</a> Tex ) [event]</dt><dd></dd><dt>ReplaceText( out string Text, string Replace, string With ) [final]</dt><dd></dd><dt>Reset()</dt><dd>Reset actor to initial state - used when restarting level without reloading.</dd><dt>SetDefaultDisplayProperties()</dt><dd></dd><dt>SetDisplayProperties( ERenderStyle NewStyle, <a href="material.html">Material</a> NewTexture, bool bLighting )</dt><dd>Set the display properties of an actor.  By setting them through this function, it allows the actor to modify other components (such as a Pawn's weapon) or to adjust the result based on other factors (such as a Pawn's other inventory wanting to affect the result).</dd><dt>SetGRI( <a href="gamereplicationinfo.html">GameReplicationInfo</a> GRI )</dt><dd></dd><dt>SetInitialState() [simulated, event]</dt><dd>Called after PostBeginPlay. See <a href="chain-of-events-at-level-st.html">chain of events at level startup</a> and <a href="chain-of-events-when-spawni.html">chain of events when spawning actors</a>.</dd><dt>SetOverlayMaterial( <a href="material.html">Material</a> mat, float time, bool bOverride ) [simulated]</dt><dd></dd><dt>StartInterpolation() [simulated]</dt><dd>when this function is called, the actor will start moving along an interpolation path beginning at Dest.</dd><dt>String GetHumanReadableName() [simulated]</dt><dd>Returns the human readable string representation of an object.</dd><dt>String GetItemName( string FullName )</dt><dd>Returns the string representation of the name of an object without the package prefixes.</dd><dt>String GetLocalString( optional int Switch, optional <a href="playerreplicationinfo.html">PlayerReplicationInfo</a> RelatedPRI_1, optional <a href="playerreplicationinfo.html">PlayerReplicationInfo</a> RelatedPRI_2 ) [static]</dt><dd>Get localized message string associated with this actor.</dd><dt>TravelPostAccept() [event]</dt><dd>Called when carried into a new level, after AcceptInventory.</dd><dt>TravelPreAccept() [event]</dt><dd>Called when carried onto a new level, before AcceptInventory.</dd><dt>TriggerEvent( Name EventName, <a href="actor.html">Actor</a> Other, <a href="pawn.html">Pawn</a> EventInstigator ) [event]</dt><dd>Trigger an <a href="event.html">event</a></dd><dt>UntriggerEvent( Name EventName, <a href="actor.html">Actor</a> Other, <a href="pawn.html">Pawn</a> EventInstigator )</dt><dd>Untrigger an event (is this an event? if not, why?)</dd><dt>UpdatePrecacheMaterials() [simulated]</dt><dd></dd><dt>UpdatePrecacheStaticMeshes() [simulated]</dt><dd></dd><dt>bool CanSplash()</dt><dd>return True in this function if the actor should make splashies</dd><dt>bool EffectIsRelevant( vector SpawnLocation, bool bForceDedicated ) [simulated]</dt><dd></dd><dt>bool IsInPain()</dt><dd>Returns true if the actor is inside a <a href="physicsvolume.html">PhysicsVolume</a> that can cause pain.</dd><dt>bool IsInVolume( <a href="volume.html">Volume</a> aVolume )</dt><dd>Returns true if the actor is inside the volume <em class="em1">Volume</em>.</dd><dt>bool NearSpot(vector Spot) [simulated, final]</dt><dd>returns true is spot is within collision cylinder.</dd><dt>bool TouchingActor( <a href="actor.html">Actor</a> A ) [simulated, final]</dt><dd>Returns true if the collision cylinders of the calling actor and the actor <em class="em1">A</em> overlap. </dd><dt>string GetDebugName()</dt><dd></dd><dt>vector GetCollisionExtent()</dt><dd></dd></dl>
<p><em class="em2">MythOpus:</em> Do you think we could add some documentation on how to get these functions to work?</p>
<p><em class="em2">MythOpus:</em> Since there are various functions only available for certain games on this page, I suggest we page different pages for each seperate game for methods.</p>
<p><em class="em2">Tarquin:</em> Good idea</p>
<p><em class="em2">MythOpus:</em> Thanks <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<p><em class="em2">EricBlade:</em> Couple things.  I did make a <a href="land-of-the-dead.html">Land of the Dead</a> page to root for that game, I hope that's acceptable.  I'm not sure if I should detail only the changes from the 2k3 Actor there, or keep the whole thing?   Second thing, the recent note on PlayerCanSeeMe() notes that bHidden makes it fail all the time, which was something that boggled my mind for a while.  So, if I wanted to make something that was invisible, but used this call, I could say, SetDrawType(DT_NONE); bHidden=False; and that would cause PlayerCanSeeMe() to work?  One last one.. I see "KRemoveAllBoneLifters" says "used to limit ragdolls" .. how is it used to do that? what does it do?</p>
<p><em class="em2">EricBlade:</em> I actually just got to testing that, setting DrawType=DT_NONE and bHidden=False will cause PlayerCanSeeMe() to work for invisible actors. \o/</p>
<h2><a name="0.21"></a>Related Topics</h2>
<ul><li><a href="karma.html">Karma</a></li>
<li><a href="sounds.html">Sounds</a></li>
</ul>
<hr class="thin"><p><a href="category-to-do.html">Category To Do</a> : Still needs work... lots to document, the functions need to be better organized into groups, and then it can all be broken up into sub-pages by group.  Some initial groups... rendering, movement, collision, physics, etc.</p>
<script type="text/javascript"><!--
 menuItemAdd("Uncategorized ", "#0.1");
menuItemAdd("Collision ", "#0.2");
menuItemAdd("Drawing ", "#0.3");
menuItemAdd("Movement ", "#0.4");
menuItemAdd("Relations ", "#0.5");
menuItemAdd("Animation ", "#0.6");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Animation Notifications ", "#0.6.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Skeletal Animation ", "#0.6.2");
menuItemAdd("URLs", "#0.7");
menuItemAdd("Rendering ", "#0.8");
menuItemAdd("Physics ", "#0.9");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Karma ", "#0.9.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Karma Ragdoll ", "#0.9.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Karma Events", "#0.9.3");
menuItemAdd("Optimization", "#0.10");
menuItemAdd("Timing ", "#0.11");
menuItemAdd("Music ", "#0.12");
menuItemAdd("Engine notification functions ", "#0.13");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Triggers ", "#0.13.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Physics &amp; world interaction ", "#0.13.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Damage &amp; Kills ", "#0.13.3");
menuItemAdd("Sound ", "#0.14");
menuItemAdd("Force Feedback ", "#0.15");
menuItemAdd("AI ", "#0.16");
menuItemAdd("??? ", "#0.17");
menuItemAdd("Disk access ", "#0.18");
menuItemAdd("Iterator functions ", "#0.19");
menuItemAdd("Scripted Actor functions ", "#0.20");
menuItemAdd("Related Topics", "#0.21");
 menuWrite() //--></script></div>
</div>

<div id="footer" class="bar">
	<p><form method="post" action="http://wiki.beyondunreal.com/wiki" enctype="application/x-www-form-urlencoded">
<a href="../index.html">Home Page</a> | <a href="actor.html">Actor</a> | <a href="recent-changes.html">Recent Changes</a><br>
Last edited May 22, 2007 14:57 <a href="http://wiki.beyondunreal.com/wiki?action=browse&diff=1&id=Actor/Methods">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /><br><br><small><a href="http://wiki.beyondunreal.com/wiki/Actor/Methods">Original page</a> &#150; copy created Sat, Jun 23, 2007</small><div></div>
</form>
	</p>
	<p>Always snap to grid
</p>
</div>
</div><!-- close of "scrolling" div -->

<div id="quickbar">
	<div id="logo"><a href="../index.html"><img src="shared/wikilogo.jpg" width="143" height="100" border="0"></a>
		</div>
	<div class="qbsitename">
		<p>The Unreal Engine Documentation Site</p>
	</div>
	<div class="qbsection">
<p><a href="metatopics.html">Wiki Community</a></p>
<p><a href="category-category.html">Topic Categories</a></p>


<p><a href="recent-changes.html">Recent Changes</a></p>
<p><a href="offline-wiki.html">Offline Wiki</a></p>
</div><div class="qbsection">
<p><a href="unreal-engine.html">Unreal Engine</a></p>
<p><a href="console-commands.html">Console Commands</a></p>
<p><a href="terminology.html">Terminology</a></p>
<p><a href="category-faq.html">FAQs</a></p>
<p><a href="help-desk.html">Help Desk</a></p>
</div><div class="qbsection">
<p><a href="topics-on-mapping.html">Mapping Topics</a></p>
<p><a href="mapping-lessons.html">Mapping Lessons</a></p>
<p><a href="unrealed-3.html">UnrealEd Interface</a></p>
</div><div class="qbsection">
<p><a href="unrealscript.html">UnrealScript Topics</a></p>
<p><a href="unrealscript-lessons.html">UnrealScript Lessons</a></p>
<p><a href="making-mods.html">Making Mods</a></p>
<p><a href="class-tree.html">Class Tree</a></p>
</div><div class="qbsection">
<p><a href="topics-on-modeling.html">Modeling Topics</a></p>
</div><div class="qbsection">
<p><a href="chongqing-page.html">Chongqing Page</a></p>
<p><a href="log-in.html">Log In</a></p></div>
</div>

</body></html>
