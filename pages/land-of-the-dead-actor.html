<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head lang="en">
	<title>UnrealWiki: Land Of The Dead/Actor</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="stylesheet" type="text/css" media="screen, print"
		href="shared/stylebase.structural.css">	
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/template-default.css">
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/styles.chblue.css">
	<link rel="stylesheet" type="text/css" media="print"
		href="shared/template-default-print.css">
	<!--[if IE 6]>
			<style>
			/* dirty hack for IE6. */
			#quickbar {
				position: absolute;
				}
			</style>
	<![endif]-->
  <link rel="start" href="http://wiki.beyondunreal.com/">
  <link rel="glossary"  href="http://wiki.beyondunreal.com/wiki/Terminology">
  <link rel="help"  href="http://wiki.beyondunreal.com/wiki/Using_The_Wiki">
<script type="text/javascript" src="shared/dhtml.js"></script>
<script type="text/javascript" src="shared/dhtml-menu.js"></script>
<style type="text/css">#dhtml-menu    { background: #eee; padding: 5px 0px; margin-right: -20px; border: 1px solid #888; border-left: 1px solid #ccc; border-top: 1px solid #ccc;  border-right: 1px solid #888; border-bottom: 1px solid #888 }
#dhtml-menu td { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; padding: 1px 10px; cursor: default }
#dhtml-menu a  { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; text-decoration: none }
#dhtml-menu tt { font-family: monospace; font-size: 9pt }
#dhtml-menu-separator { height: 1px; background: red }
#dhtml-menu-anchor { cursor: default }
</style>
<script type="text/javascript" src="shared/expandable.js"></script>
</head>
<body onLoad="menuInit(); document.cookie='page=Land_Of_The_Dead/Actor; path=/'" class="default">
<div id="scrolling"><!-- contains all except the fixed sidebar -->
<div id="topbar"  class="bar">
	<div class="righthalf">
		<form class="inline" method="post" action="/wiki" enctype="application/x-www-form-urlencoded"><input type="text" name="search"  size="20" /> <input type="submit" name="search" value="search" /></form>
	</div>
	<div class="lefthalf">
		<script type="text/javascript"><!--
			menuAlignRight = false;
		//--></script>
		<span><script type="text/javascript"><!--
 menuWriteAnchor("Quick Navigation") //--></script></span> | <a href="../index.html">Home Page</a> | <a href="recent-changes.html">Recent Changes</a>
	</div>
</div>

<div id="content"><!-- contains the title and article -->
	<h1 class='pagetitle'><a href="land-of-the-dead.html">Land Of The Dead</a>/<a href="http://wiki.beyondunreal.com/wiki?back=Land+Of+The+Dead/Actor">Actor</a></h1>
	<div class="wiki"><div class="classpath"><a href="land-of-the-dead.html">Land of the Dead</a> :: <a href="object.html">Object</a> &gt;&gt; <a href="actor.html">Actor</a><br></div>
<h2><a name="0.1"></a>Constants</h2>
<dl><dt>MAXSTEPHEIGHT = 35.0</dt><dd>Maximum step height walkable by Pawns</dd><dt>MINFLOORZ = 0.7</dt><dd>Minimum Z value for floor normal. Anything that's less, isn't a walkable floor. (0.7 corresponds to about 45 degree angle for floor)</dd></dl>
<h2><a name="0.2"></a>Properties</h2>
<dl><dt>vector Acceleration</dt><dd>Actor's movement acceleration</dd><dt>ActorRenderDataPtr ActorRenderData</dt><dd></dd><dt>array&lt;Actor&gt; Attached</dt><dd>Array of actors attached to this actor.</dd><dt>name AttachmentBone</dt><dd>Name of bone to which actor is attached </dd><dt>bool bAlwaysRelevant</dt><dd>When true, this Actor will be Always relevant for network.</dd><dt>bool bAlwaysTick</dt><dd>Update even when players-only is turned on.</dd><dt>bool bAlwaysZeroBoneOffset</dt><dd>If true, offset always zero when attached to skeletalmesh.</dd><dt>bool bAnimByOwner</dt><dd>Animation dictated by owner.</dd><dt>Actor Base</dt><dd>Actor we're standing on, or attached to with SetBase</dd><dt>bool bCanBeDamaged</dt><dd>Can take damage. (this doesn't seem to be used much, a lot of actors implement their own Can Damage functions)</dd><dt>bool bClientAnim</dt><dd>Don't replicate any animations - animation done client-side.</dd><dt>bool bClientDemoNetFunc</dt><dd>True if we're client-side demo recording and this call originated from the remote.</dd><dt>bool bClientDemoRecording</dt><dd>True if we are currently recording a client-side demo.</dd><dt>bool bCompressedPosition</dt><dd>Used by networking code to flag compressed position replication.</dd><dt>bool bDeleteMe</dt><dd>This is set true for items that have had Destroy() called, but are not completely destroyed yet. </dd><dt>bool bDemoOwner</dt><dd>Demo recording driver owns this actor.</dd><dt>bool bDemoRecording</dt><dd>True we are currently demo recording.</dd><dt>bool bDestroyInPainVolume</dt><dd>Destroy this actor if it enters a pain volume.</dd><dt>bool bDisturbFluidSurface</dt><dd>Cause ripples when in contact with FluidSurface.</dd><dt>bool bEdSnap</dt><dd>Should snap to grid in UnrealEd.</dd><dt>bool bHurtEntry</dt><dd>This is a hack to keep HurtRadius from being reentrant, Epic probably should've used singular here, but I'm guessing singular didn't exist when they wrote that code.</dd><dt>bool bIgnoreOutOfWorld</dt><dd>Don't destroy if enters zone zero.</dd><dt>bool bInterpolating</dt><dd>Performing interpolating.</dd><dt>bool bJustTeleported</dt><dd>Used by engine physics - not valid for scripts.</dd><dt>bool bLightChanged</dt><dd>Set by the Editor to determine if this actor's lighting properties have been changed (for Build Changed Lighting) </dd><dt>bool bNetDirty</dt><dd>Set true when any replicated variable is set in Unrealscript, mostly used in Replication block conditions</dd><dt>bool bNetInitial</dt><dd>True for the initial network update.</dd><dt>bool bNetInitialRotation</dt><dd>Should replicate initial rotation.</dd><dt>bool bNetNotify</dt><dd>The actor wishes to be notified of replication events. The actor gets the simulated function PostNetReceive() called whenever replication occurs, e.g. in Ammunition whenever AmmoAmount gets changed.</dd><dt>bool bNetOwner</dt><dd>Player owns this actor. (Used mainly in replication blocks)</dd><dt>bool bNetRelevant</dt><dd>Actor is currently relevant. Only valid server side, only when replicating variables.</dd><dt>bool bNetTemporary</dt><dd>Tear-off simulation in network play.</dd><dt>bool bNoRepMesh</dt><dd>Don't replicate mesh.</dd><dt>bool bObsolete</dt><dd>Actor is obsolete - warn level designers to remove it.</dd><dt>bool bOnlyAffectPawns</dt><dd>Optimisation - only test ovelap against pawns. Used for influences etc.</dd><dt>bool bOnlyDirtyReplication</dt><dd>If true, only replicate actor if <code>bNetDirty</code> is true - useful if no C++ changed attributes (such as physics)<br /></dd><dt>bool bOnlyDrawIfAttached</dt><dd>Don't draw this actor if not attached (useful for net clients where attached actors and their bases' replication may not be synched).</dd><dt>bool bOnlyOwnerSee</dt><dd>Only owner can see this actor.</dd><dt>bool bOnlyRelevantToOwner</dt><dd>This actor is only relevant to its owner.</dd><dt>bool bOrientOnSlope</dt><dd>When landing, orient base on slope of floor.</dd><dt>bool bOwnerNoSee</dt><dd>Everything but the owner can see this actor.</dd><dt>bool bPathTemp</dt><dd>Internal/path building.</dd><dt>bool bPendingDelete</dt><dd>Set when actor is about to be deleted (since endstate and other functions called during deletion process before <code>bDeleteMe</code> is set).</dd><dt>bool bRepClientDemo</dt><dd>True if remote client is recording demo.</dd><dt>bool bReplicateAnimations</dt><dd>Should replicate SimAnim.</dd><dt>bool bReplicateInstigator</dt><dd>Replicate instigator to client (used by bNetTemporary projectiles).</dd><dt>bool bReplicateMovement</dt><dd>If true, replicate movement/location related properties.</dd><dt>model Brush</dt><dd>Brush if <code>DrawType=DT_Brush</code>.</dd><dt>bool bScriptInitialized</dt><dd>Set to prevent re-initializing of actors spawned during level startup</dd><dt>bool bSelected</dt><dd>Selected in UnrealEd.</dd><dt>bool bShowOctreeNodes</dt><dd></dd><dt>bool bSkipActorPropertyReplication</dt><dd>If true, don't replicate actor class variables for this actor.</dd><dt>bool bTearOff</dt><dd>If true, this actor is no longer replicated to new clients, and is "torn off" (becomes a <code>ROLE_Authority</code>) on clients to which it was being replicated.</dd><dt>bool bTempEditor</dt><dd></dd><dt>bool bTicked</dt><dd>Actor has been updated.</dd><dt>bool bTimerLoop</dt><dd>Timer loops (else is one-shot).</dd><dt>bool bTrailerAllowRotation</dt><dd>If <code>PHYS_Trailer</code> and want independent rotation control.</dd><dt>bool bTrailerPrePivot</dt><dd>If <code>PHYS_Trailer</code> and true, offset from owner by <code>PrePivot</code>.</dd><dt>bool bTrailerSameRotation</dt><dd>If <code>PHYS_Trailer</code> and true, have same rotation as owner.</dd><dt>bool bTravel</dt><dd>Actor is capable of travelling among servers.</dd><dt>bool bUpdateSimulatedPosition</dt><dd>f true, update velocity/location after initialization for simulated proxies.</dd><dt>bool bWasSNFiltered</dt><dd>Mainly for debugging - the way this actor was inserted into Octree.</dd><dt>bool bWorldGeometry</dt><dd>Collision and Physics treats this actor as world geometry.</dd><dt>Matrix CachedLocalToWorld</dt><dd></dd><dt>vector CachedLocation</dt><dd></dd><dt>Rotator CachedRotation</dt><dd></dd><dt>int CollisionTag</dt><dd></dd><dt>vector ColLocation</dt><dd>Actor's old location one move ago. Only for debugging.</dd><dt>actor Deleted</dt><dd>Next actor in just-deleted chain.</dd><dt>Matrix HardRelMatrix</dt><dd>Transform of actor in base's ref frame. Doesn't change after SetBase.</dd><dt>Pawn Instigator</dt><dd>Pawn responsible for damage caused by this actor.</dd><dt>Inventory Inventory</dt><dd>Inventory chain.</dd><dt>int JoinedTag</dt><dd></dd><dt>int KStepTag</dt><dd></dd><dt>float LastRenderTime</dt><dd>Last time this actor was rendered.</dd><dt>float LatentFloat</dt><dd>Internal latent function use.</dd><dt>array&lt;int&gt; Leaves</dt><dd>BSP leaves this actor is in.</dd><dt>LevelInfo Level</dt><dd>Level this actor is on.</dd><dt>LightRenderDataPtr LightRenderData</dt><dd></dd><dt>MeshInstance MeshInstance</dt><dd>Mesh instance.</dd><dt>class&lt;LocalMessage&gt; MessageClass</dt><dd></dd><dt>array&lt;timerStruct&gt; MultiTimers</dt><dd>Used internally by the Land of the Dead SetMultiTimer() native function</dd><dt>float NetPriority</dt><dd>Higher priorities means update it more frequently.</dd><dt>int NetTag</dt><dd></dd><dt>float NetUpdateFrequency</dt><dd>How many net updates per seconds.</dd><dt>float NetUpdateTime</dt><dd>Time of last update</dd><dt>Box OctreeBox</dt><dd>Actor bounding box cached when added to Octree. Internal use only.</dd><dt>vector OctreeBoxCenter</dt><dd></dd><dt>vector OctreeBoxRadii</dt><dd></dd><dt>array&lt;int&gt; OctreeNodes</dt><dd>Array of nodes of the octree Actor is currently in. Internal use only.</dd><dt>Actor Owner</dt><dd>Owner actor, usually set in Spawn()</dd><dt>Actor PendingTouch</dt><dd>Actor touched during move which wants to add an effect after the movement completes.</dd><dt>PhysicsVolume PhysicsVolume</dt><dd>physics volume this actor is currently in.</dd><dt>array&lt;ProjectorRenderInfoPtr&gt; Projectors</dt><dd>Projected textures on this actor.</dd><dt>PointRegion Region</dt><dd>Region this actor is in.</dd><dt>vector RelativeLocation</dt><dd>Location relative to base/bone (valid if base exists).</dd><dt>rotator RelativeRotation</dt><dd>Rotation relative to base/bone (valid if base exists)</dd><dt>ENetRole RemoteRole</dt><dd>Default <a href="replication.html">Replication</a> role</dd><dt>int RenderRevision</dt><dd></dd><dt>Material RepSkin</dt><dd>Replicated skin, covers all material slots, as far as I can tell</dd><dt>ENetRole Role</dt><dd>Net Role used in <a href="replication.html">Replication</a></dd><dt>AnimRep SimAnim</dt><dd>Only replicated if <code>bReplicateAnimations</code> is true</dd><dt>EFilterState StaticFilterState</dt><dd></dd><dt>StaticMeshInstance StaticMeshInstance</dt><dd>Contains per-instance static mesh data, like static lighting data.</dd><dt>array&lt;StaticMeshProjectorRenderInfoPtr&gt; StaticMeshProjectors</dt><dd></dd><dt>array&lt;BatchReference&gt; StaticSectionBatches</dt><dd></dd><dt>float TimerCounter</dt><dd>Counts up until it reaches TimerRate.</dd><dt>float TimerRate</dt><dd>Timer event, 0=no timer.</dd><dt>array&lt;Actor&gt; Touching</dt><dd>List of touching actors.</dd><dt>Level XLevel</dt><dd>Level object.</dd></dl>
<h3><a name="0.2.1"></a>Actionable</h3>
<dl><dt>string ActionableMessage</dt><dd>A message to display to a player when near the object</dd><dt>int iActionablePriority</dt><dd>Priority if near several Actionable objects</dd><dt>int iActionableRadius</dt><dd>Radius to be Actionable within</dd></dl>
<h3><a name="0.2.2"></a>Advanced</h3>
<dl><dt>bool bCanTeleport</dt><dd>This actor can be teleported. This property must be True for Teleporters to notice the actor.</dd><dt>bool bCollideWhenPlacing</dt><dd>The actor will collide with world geometry when placed.</dd><dt>bool bDirectional</dt><dd>Whether the editor should display an arrow to show the actor's current rotation. This has no effect in the game.</dd><dt>bool bEdShouldSnap</dt><dd>Snap to grid in the editor.</dd><dt>bool bGameRelevant</dt><dd>Mutators will not receive CheckReplacement and AlwaysKeep calls for the actor if this property is True.</dd><dt>bool bHidden</dt><dd>Specifies, whether the actor is invisible in the game. This property has no effect in the editor.</dd><dt>bool bHiddenEd</dt><dd>The actor is hidden in the editor. This has no effect in the game.</dd><dt>bool bHiddenEdGroup</dt><dd>The actor is hidden in the Group Browser. This has no effect in the editor viewports or in the game.</dd><dt>bool bHighDetail</dt><dd>The actor only shows up in high or super high detail mode.</dd><dt>bool bLockLocation</dt><dd>Prevent the actor from being moved in the editor.</dd><dt>bool bMovable</dt><dd>Actor can be moved.</dd><dt>bool bNoDelete</dt><dd>Specifies, that the actor can't be spawned or destroyed during the game.</dd><dt>bool bShouldBaseAtStartup</dt><dd>The actor tries to find another actor for its Base at level startup if its Physics property is set to either PHYS_None or PHYS_Rotating.</dd><dt>bool bStasis</dt><dd>In standalone (i.e. single player, e.g. Instant Action) games this actor should be turned off if it's not in a recently rendered zone. It will only be turned off when its Physics mode is PHYS_None or PHYS_Rotating.</dd><dt>bool bSuperHighDetail</dt><dd>The actor only shows up in super high detail mode.</dd><dt>float LifeSpan</dt><dd>Specifies how long the actor will exist. This value is constantly decreased and the actor will be destroyed when it reaches 0. In this case the actor's Expired method is executed. An initial LifeSpan of 0 or explicitely setting the LifeSpan to 0 from UnrealScript disables the actor's "destruction timer". Setting it to a value greater 0 from UnrealScript enables it and the Actor will be destroyed after that time unless LifeSpan is set to 0 again before it expired.</dd></dl>
<h3><a name="0.2.3"></a>BreakNetPlay</h3>
<dl><dt>bool bStatic</dt><dd>Does not move or change over time. Don't let L.D.s change this - screws up net play.</dd></dl>
<h3><a name="0.2.4"></a>Collision</h3>
<dl><dt>bool bAutoAlignToTerrain</dt><dd>Auto-align to terrain in the editor.</dd><dt>bool bBlockActors</dt><dd>Blocks other nonplayer actors.</dd><dt>bool bBlockKarma</dt><dd>Block actors being simulated with Karma.</dd><dt>bool bBlockNonZeroExtentTraces</dt><dd>Block non-zero extent actors/traces.</dd><dt>bool bBlockPlayers</dt><dd>The comment for this says "OBSOLETE - no longer used", but it seems to be quite required if you want something to block player movement.  Anyone have ideas?</dd><dt>bool bBlockZeroExtentTraces</dt><dd>Block zero extent actors/traces, such as normal bullet fire, and any regular Trace() calls</dd><dt>bool bCollideActors</dt><dd>Collides with other actors.</dd><dt>bool bCollideWorld</dt><dd>Collides with the world.</dd><dt>bool bPathColliding</dt><dd>This actor should collide (if <code>bWorldGeometry &amp;&amp; bBlockActors</code> is true) during path building (ignored if <code>bStatic</code> is true, as actor will always collide during path building).</dd><dt>bool bProjTarget</dt><dd><a href="projectile.html">Projectile</a>s will Explode() when touching an actor with bProjTarget = True</dd><dt>bool bUseCylinderCollision</dt><dd>Force axis aligned cylinder collision (useful for static mesh pickups, etc.).</dd><dt>float CollisionHeight</dt><dd>Half-height cyllinder.</dd><dt>float CollisionRadius</dt><dd>Radius of collision cyllinder.</dd></dl>
<h3><a name="0.2.5"></a>Display</h3>
<dl><dt>byte AmbientGlow</dt><dd>Ambient brightness, or 255=pulsing.  </dd></dl>
<p><em class="em2">EricBlade:</em> Pulsing?  Anyone ever see that?</p>
<dl><dt>ConvexVolume AntiPortal</dt><dd>Convex volume used for DT_AntiPortal.</dd><dt>bool bAcceptsProjectors</dt><dd>Projectors can project onto this actor.</dd><dt>bool bDisableSorting</dt><dd>Manual override for translucent material sorting.</dd><dt>bool bShadowCast</dt><dd>Used in the editor to determine if this actor should be considered when drawing shadows</dd><dt>bool bStaticLighting</dt><dd>Uses raytraced lighting.</dd><dt>bool bUnlit</dt><dd>Lights don't affect actor, it will be displayed at it's full brightness.</dd><dt>bool bUseDynamicLights</dt><dd>If true, Dynamic lights will shine on this actor</dd><dt>bool bUseLightingFromBase</dt><dd>Use Unlit/AmbientGlow from Base.</dd><dt>float CullDistance</dt><dd>0=no distance cull, &lt; 0 only drawn at distance &gt; 0 cull at distance.</dd><dt>float DrawScale</dt><dd>Scaling factor, 1.0=normal size.</dd><dt>vector DrawScale3D</dt><dd>Scaling vector, <code>(1.0,1.0,1.0)</code>=normal size. Use negative numbers to mirror the actor along the axis that is negative. NOTE: In most actors, DrawScale3D is NOT replicated, so it's pretty much useless in net play!</dd><dt>EDrawType DrawType</dt><dd>Internal enum representing what type of thing to display here, Mesh, StaticMesh, etc</dd><dt>name ForcedVisibilityZoneTag</dt><dd>Makes the visibility code treat the actor as if it was in the zone with the given tag.</dd><dt>float LODBias</dt><dd></dd><dt>byte MaxLights</dt><dd>Limit to hardware lights active on this primitive.</dd><dt>mesh Mesh</dt><dd>Mesh if <code>DrawType=DT_Mesh</code>.</dd><dt>vector PrePivot</dt><dd>Offset from box center for drawing.</dd><dt>float ScaleGlow</dt><dd>Similar to AmbientGlow, not quite sure how it differs</dd><dt>array&lt;Material&gt; Skins</dt><dd>Multiple skin support - not replicated. Overrides the default materials of a mesh or static mesh</dd><dt>StaticMesh StaticMesh</dt><dd>StaticMesh if <code>DrawType=DT_StaticMesh</code></dd><dt>ERenderStyle Style</dt><dd>Style for rendering sprites, meshes.</dd><dt>Material Texture</dt><dd>Sprite texture. If <code>DrawType=DT_Sprite</code></dd></dl>
<h3><a name="0.2.6"></a>Events</h3>
<dl><dt>bool bHasHandlers</dt><dd>If this is set, TriggerEx() will be called to handle events, to deal with LOTD's custom multi-event system</dd><dt>name Event</dt><dd>The event this actor causes.</dd><dt>array&lt;EventHandlerMapping&gt; EventBindings</dt><dd>Used to create a list of Events that this actor will respond to, used in conjunction with bHasHandlers</dd><dt>name Tag</dt><dd>Actor's tag name.</dd></dl>
<h3><a name="0.2.7"></a>Force</h3>
<dl><dt>float ForceRadius</dt><dd>Radius that forces are applied to Emitters that have Forces enabled</dd><dt>float ForceScale</dt><dd>Scale to apply to forces</dd><dt>EForceType ForceType</dt><dd>Type of force to apply to particles that are force enabled</dd></dl>
<h3><a name="0.2.8"></a>Karma</h3>
<dl><dt><a href="karmaparamscollision.html">KarmaParamsCollision</a> KParams</dt><dd>Parameters for Karma Collision/Dynamics.</dd></dl>
<h3><a name="0.2.9"></a>LightColor</h3>
<dl><dt>float LightBrightness</dt><dd>Brightness of light this actor is to emit</dd><dt>byte LightHue</dt><dd>Hue for light this actor is to emit</dd><dt>byte LightSaturation</dt><dd>Saturation for light this actor is to emit</dd></dl>
<h3><a name="0.2.10"></a>Lighting</h3>
<dl><dt>bool bActorShadows</dt><dd>Light casts actor shadows.</dd><dt>bool bCorona</dt><dd>Light uses Skin[0] as a corona.</dd><dt>bool bDynamicLight</dt><dd>This light is dynamic.</dd><dt>bool bLightingVisibility</dt><dd>Calculate lighting visibility for this actor with line checks.</dd><dt>bool bSpecialLit</dt><dd>Only affects special-lit surfaces.</dd><dt>byte LightCone</dt><dd>Used with LT_SpotLight effect to determine the size of the spot cone</dd><dt>ELightEffect LightEffect</dt><dd></dd><dt>byte LightPeriod</dt><dd>Used with some of the dynamic LightEffects</dd><dt>byte LightPhase</dt><dd>Used with some of the dynamic LightEffects</dd><dt>float LightRadius</dt><dd>Radius for lights to affect, note this has nothing to do with Unreal units, or any other known direct measurement.</dd><dt>ELightType LightType</dt><dd></dd></dl>
<h3><a name="0.2.11"></a>Movement</h3>
<dl><dt>name AttachTag</dt><dd>Attach this actor's movement to the mover with the specified Tag set - note that LOTD suffers from an apparent engine bug that makes this a real bear to get working in netplay.</dd><dt>bool bBounce</dt><dd>Bounces when hits ground fast.</dd><dt>bool bFixedRotationDir</dt><dd>Fixed direction of rotation.</dd><dt>bool bHardAttach</dt><dd>Uses 'hard' attachment code. <code>bBlockActor</code> and <code>bBlockPlayer</code> must also be false.<br /><br>This actor cannot then move relative to base (setlocation etc.).<br /></dd><dt>bool bIgnoreEncroachers</dt><dd>Ignore collisions between movers and this actor.</dd><dt>bool bRotateToDesired</dt><dd>Rotate to DesiredRotation.</dd><dt>float Buoyancy</dt><dd>Water buoyancy.</dd><dt>rotator DesiredRotation</dt><dd>Physics will smoothly rotate actor to this rotation if <code>bRotateToDesired</code>.</dd><dt>vector Location</dt><dd>Actor's location; use SetLocation() to set.</dd><dt>float Mass</dt><dd>Mass of this actor.</dd><dt>EPhysics Physics</dt><dd>The type of Physics in use for this actor</dd><dt>rotator Rotation</dt><dd>Actor's rotation</dd><dt>rotator RotationRate</dt><dd>Change in rotation per second.</dd><dt>vector Velocity</dt><dd>Actor's velocity</dd></dl>
<h3><a name="0.2.12"></a>Object</h3>
<dl><dt>int DebugFlags</dt><dd></dd><dt>name Group</dt><dd>The Group this actor is in within the Editor</dd><dt>name InitialState</dt><dd>Initial code state to start in</dd></dl>
<h3><a name="0.2.13"></a>Sound</h3>
<dl><dt>sound AmbientSound</dt><dd>Ambient sound effect.</dd><dt>bool bFullVolume</dt><dd>Whether to apply ambient attenuation.</dd><dt>ESoundOcclusion SoundOcclusion</dt><dd>Sound occlusion approach.</dd><dt>byte SoundPitch</dt><dd>Sound pitch shift, 64.0=none.</dd><dt>float SoundRadius</dt><dd>Radius of ambient sound. (It will be audible out to SoundRadius * 100 UU from this actor)</dd><dt>byte SoundVolume</dt><dd>Volume of ambient sound.</dd><dt>float TransientSoundRadius</dt><dd>Default sound radius for regular sounds (can be overridden in playsound).</dd><dt>float TransientSoundVolume</dt><dd>Default sound volume for regular sounds (can be overridden in playsound).</dd></dl>
<h2><a name="0.3"></a>Enums</h2>
<h3><a name="0.3.1"></a>EDetailMode</h3>
<dl><dt>DM_Low</dt><dd>Low detail mode</dd><dt>DM_High</dt><dd>High detail mode</dd><dt>DM_SuperHigh</dt><dd>Super High detail mode</dd></dl>
<h3><a name="0.3.2"></a>EDoubleClickDir</h3>
<p>Double click move direction.<br /><br>Used to remember the dodging state of a player. This will be reset to DCLICK_None when the player lands.<br>These are not used in LOTD.</p>
<p><dl><br><dt>DCLICK_None</dt><dd>No dodging move started.</dd><br><dt>DCLICK_Active</dt><dd>In dodging move.</dd><br><dt>DCLICK_Done</dt><dd>Dodging move done.</dd></dl>
</p>
<dl><dt>DCLICK_None</dt><dd></dd><dt>DCLICK_Left</dt><dd></dd><dt>DCLICK_Right</dt><dd></dd><dt>DCLICK_Forward</dt><dd></dd><dt>DCLICK_Back</dt><dd></dd><dt>DCLICK_Active</dt><dd></dd><dt>DCLICK_Done</dt><dd></dd></dl>
<h3><a name="0.3.3"></a>EDrawType</h3>
<p>The DrawType enumneration sets how the actor displays. Some of these options work with another property to set what is displayed.<br><dl><br><dt>DT_None</dt><br><dd>The actor isn't displayed at all. <code>bHidden</code> instead in most cases because it will allow the actor to still show up in UnrealEd.</dd><br><dt>DT_Sprite</dt><br><dd>Display a sprite with the material set in the Texture property.</dd><br><dt>DT_Mesh</dt><br><dd>Display the mesh set in the Mesh property.</dd><br><dt>DT_Brush</dt><br><dd>Only for Brush classes.</dd><br><dt>DT_RopeSprite</dt><br><dt>DT_VerticalSprite</dt><br><dt>DT_Terraform</dt><br><dt>DT_SpriteAnimOnce</dt><br><dd>Like DT_Sprite, but plays an animated texture's animation at a speed that plays the animation exactly once during the LifeSpan of the actor. </dd><br><dt>DT_StaticMesh</dt><br><dd>Display the static mesh set in the StaticMesh property.</dd><br><dt>DT_DrawType</dt><br><dt>DT_Particle</dt><br><dd>Used by particle effect actors (Emitter, xEmitter, xWeatherEffect) and xProcMeshes.</dd><br><dt>DT_AntiPortal</dt><br><dd>Used for Antiportals.</dd><br><dt>DT_FluidSurface</dt><br><dd>Used by FluidSurfaceInfos. See Fluid Surfaces.</dd></dl>
</p>
<dl><dt>DT_None</dt><dd></dd><dt>DT_Sprite</dt><dd></dd><dt>DT_Mesh</dt><dd></dd><dt>DT_Brush</dt><dd></dd><dt>DT_RopeSprite</dt><dd></dd><dt>DT_VerticalSprite</dt><dd></dd><dt>DT_Terraform</dt><dd></dd><dt>DT_SpriteAnimOnce</dt><dd></dd><dt>DT_StaticMesh</dt><dd></dd><dt>DT_DrawType</dt><dd></dd><dt>DT_Particle</dt><dd></dd><dt>DT_AntiPortal</dt><dd></dd><dt>DT_FluidSurface</dt><dd></dd></dl>
<h3><a name="0.3.4"></a>EFilterState</h3>
<dl><dt>FS_Maybe</dt><dd></dd><dt>FS_Yes</dt><dd></dd><dt>FS_No</dt><dd></dd></dl>
<h3><a name="0.3.5"></a>EForceType</h3>
<dl><dt>FT_None</dt><dd>Actor does not apply forces</dd><dt>FT_DragAlong</dt><dd>Actor drags particles with it, if the particle emitter is set to use Forces</dd></dl>
<h3><a name="0.3.6"></a>eKillZType</h3>
<dl><dt>KILLZ_None</dt><dd>Actor killZ will be killed with no damage type</dd><dt>KILLZ_Lava</dt><dd>Actor killZ will be killed with Lava damage type</dd><dt>KILLZ_Suicide</dt><dd>Actor KillZ will be killed with Suicide damage type</dd></dl>
<h3><a name="0.3.7"></a>ELightEffect</h3>
<p>Spatial light effect to use.</p>
<dl><dt>LE_None</dt><dd></dd><dt>LE_TorchWaver</dt><dd></dd><dt>LE_FireWaver</dt><dd></dd><dt>LE_WateryShimmer</dt><dd></dd><dt>LE_Searchlight</dt><dd></dd><dt>LE_SlowWave</dt><dd></dd><dt>LE_FastWave</dt><dd></dd><dt>LE_CloudCast</dt><dd></dd><dt>LE_StaticSpot</dt><dd></dd><dt>LE_Shock</dt><dd></dd><dt>LE_Disco</dt><dd></dd><dt>LE_Warp</dt><dd></dd><dt>LE_Spotlight</dt><dd></dd><dt>LE_NonIncidence</dt><dd></dd><dt>LE_Shell</dt><dd></dd><dt>LE_OmniBumpMap</dt><dd></dd><dt>LE_Interference</dt><dd></dd><dt>LE_Cylinder</dt><dd></dd><dt>LE_Rotor</dt><dd></dd><dt>LE_Sunlight</dt><dd></dd><dt>LE_QuadraticNonIncidence</dt><dd></dd></dl>
<h3><a name="0.3.8"></a>ELightType</h3>
<p>Light modulation.</p>
<dl><dt>LT_None</dt><dd></dd><dt>LT_Steady</dt><dd></dd><dt>LT_Pulse</dt><dd></dd><dt>LT_Blink</dt><dd></dd><dt>LT_Flicker</dt><dd></dd><dt>LT_Strobe</dt><dd></dd><dt>LT_BackdropLight</dt><dd></dd><dt>LT_SubtlePulse</dt><dd></dd><dt>LT_TexturePaletteOnce</dt><dd></dd><dt>LT_TexturePaletteLoop</dt><dd></dd><dt>LT_FadeOut</dt><dd></dd></dl>
<h3><a name="0.3.9"></a>EMusicTransition</h3>
<p>Music transitions.</p>
<dl><dt>MTRAN_None</dt><dd></dd><dt>MTRAN_Instant</dt><dd></dd><dt>MTRAN_Segue</dt><dd></dd><dt>MTRAN_Fade</dt><dd></dd><dt>MTRAN_FastFade</dt><dd></dd><dt>MTRAN_SlowFade</dt><dd></dd></dl>
<h3><a name="0.3.10"></a>ENetRole</h3>
<p>Net variables.<br><dl><br><dt>ROLE_None</dt><dd><br>This means that none of the actor's attributes will not be replicated at all. Examples for this kind of actors are the GameInfo, Mutators and GameRules as well as some explosion effects and decals in UT. Note that Actor's with this role can still be instantiated on network game clients if spawned from the right function. For example if an Actor with <code>ROLE_None</code> is instantiated from a <code>simulated event PostBeginPlay()</code> function it will be created on both the server and the client as this function is invoked on both. However the server-side Actor and the client-side Actor are two completely independant entities. This means that destroying the actor on the server will not destroy the actor on the client (and vice-versa).<br></dd><br><dt>ROLE_DumbProxy</dt><dd>The actor is replicated, but can't execute any functions on the remote side. It will update when variables are replicated to it but will not attempt to interpolate.</dd><br><dt>ROLE_SimulatedProxy</dt><dd>The actor is replicated and may execute simulated functions and simulated state code on the remote side. Often this kind of actor simulates its behavior based on initially replicated properties without (much) further "help" from the server.</dd><br><dt>ROLE_AutonomousProxy</dt><dd><br>Autonomous proxies come with some more magic built-in. They are basically simulated proxies, but may execute simulated and non-simulated functions on the client owning/controlling this actor (only on that client!).<br>In UT only PlayerPawns are autonomous proxies, in UT2003 only PlayerControllers are. Every other client sees them as a regular simulated proxy. Player-controlled actors, such as the guided redeemer missile (GuidedWarshell in UT or RedeemerWarhead in UT2003) are autonomous proxies on the controlling player's client, too.<br></dd><br><dt>ROLE_Authority</dt><dd><br>All functions can be executed. This role is only allowed on the machine the actor was spawned on. All actors on the server or in standalone games have <code>Role== ROLE_Authority</code>. Never manually set the <code>RemoteRole</code> on the authorative version of an actor or the <code>Role</code> on a replicated version of the actor to this value.<br></dd></dl>
</p>
<dl><dt>ROLE_None</dt><dd></dd><dt>ROLE_DumbProxy</dt><dd></dd><dt>ROLE_SimulatedProxy</dt><dd></dd><dt>ROLE_AutonomousProxy</dt><dd></dd><dt>ROLE_Authority</dt><dd></dd></dl>
<h3><a name="0.3.11"></a>EPhysics</h3>
<p>Actor's PhysicsType is set in the Physics property. Use the <code>SetPhysics() method to change.</code><br><dl><br><dt>PHYS_CinMotion</dt><dd>(new in UT2003)</dd><br><dt>PHYS_Falling</dt><dd>Automatically applies the gravity of the current zone.  Pawn-set acceleration in the Z direction is ignored.</dd><br><dt>PHYS_Flying</dt><dd>The Pawn or Actor can move independantly from gravity. Velocity on the Z axis is ignored.</dd><br><dt>PHYS_Hovering</dt><dd>This is is a fun Physics type. When you an actors physics to <code>PHYS_Hovering</code>, it, er, hovers a few UU off the ground. If you do this to an xPawn, for example, it will act kind of like a hovercraft. Friction is reduced (so you slide around, and slide down ramps), and if you go at speed up an incline you can do some massive jumps.</dd><br><dt>PHYS_Interpolating</dt><dd>Used in conjunction with <code>bInterpolating</code> in Actor.  Seems to also use the <code>PhysRate</code> and <code>PhysAlpha</code> parameters. Seems to be a leftover from the pre-Matinee days.</dd><br><dt>PHYS_Karma</dt><dd>Signals an Actor is to be effected by the Karma engine.</dd><br><dt>PHYS_KarmaRagDoll</dt><dd>This is used for dead pawns.</dd><br><dt>PHYS_Ladder</dt><dd>Applies to an Actor when they are climbing a ladder. </dd><br><dt>PHYS_MovingBrush</dt><dd>Used for Movers</dd><br><dt>PHYS_None</dt><dd>No native physics code is applied.</dd><br><dt>PHYS_Projectile</dt><dd>Uses velocities on all 3 axes but DOES NOT use the current Zone's ZoneGravity and ZoneFluidFriction members to adjust velocity. This means that actors with a velocity are not affected by gravity or friction. Actors with this physics setting do not have any freedom of movement.</dd><br><dt>PHYS_Rolling</dt><dd>(removed in UT2003)</dd><br><dt>PHYS_RootMotion</dt><dd>(new in UT2003)</dd><br><dt>PHYS_Rotating</dt><dd>Only rotation changes.  Location doesn't change.  If <code>bRotateToDesired</code> is false, then the Actor rotates according to <code>RotationRate</code>.  If <code>bRotateToDesired</code> is true, then the Actor rotates to the rotation specified by <code>DesiredRotation</code> at the speed specified by <code>RotationRate</code>.</dd><br><dt>PHYS_Spider</dt><dd>Similar to <code>PHYS_Walking</code> except it applies to an Actor against any surface, not just a "ground" surface. An Actor in <code>PHYS_Spider</code> will move against a horizontal or vertical surface just like in <code>PHYS_Walking</code>. When the end of the surface is reached the Pawn will be set to <code>PHYS_Falling</code>. <code>PHYS_Spider</code> only works on one plane, it will not allow a Pawn to move across perpendicular walls.</dd><br><dt>PHYS_Swimming</dt><dd>Similar to <code>PHYS_Flying</code>, but also take the zone's FluidFriction into account.</dd><br><dt>PHYS_Trailer</dt><dd>Used to set an Actor to follow its Owner. An Actor set this way has no physics of its own, (*including collision) and simply follow their Owner around. NOTE: There are two settings in the Actor class which can specify the actions of a <code>PHYS_Trailer</code>. First is <code>bTrailerPrePivot</code>, which, when set to True, causes the Actor in <code>PHYS_Trailer</code> to be positioned away from its Owner by the vector value set in <code>PrePivot</code>. If not set or left at 0, the Actor in <code>PHYS_Trailer</code> will have the same location as its Owner. Secondly, there is <code>bTrailerSameRotation</code>, which causes the Actor in <code>PHYS_Trailer</code> to have the same Rotation as its Owner no matter where it is.</dd><br><dt>PHYS_Walking</dt><dd>Native physics code for Pawn class only. Applies all the things that make a pawn move around on the ground. Must have a Base set, without a Base to walk on, this turns to <code>PHYS_Falling</code>.</dd></dl>
</p>
<dl><dt>PHYS_None</dt><dd></dd><dt>PHYS_Walking</dt><dd></dd><dt>PHYS_Falling</dt><dd></dd><dt>PHYS_Swimming</dt><dd></dd><dt>PHYS_Flying</dt><dd></dd><dt>PHYS_Rotating</dt><dd></dd><dt>PHYS_Projectile</dt><dd></dd><dt>PHYS_Interpolating</dt><dd></dd><dt>PHYS_MovingBrush</dt><dd></dd><dt>PHYS_Spider</dt><dd></dd><dt>PHYS_Trailer</dt><dd></dd><dt>PHYS_Ladder</dt><dd></dd><dt>PHYS_RootMotion</dt><dd></dd><dt>PHYS_Karma</dt><dd></dd><dt>PHYS_KarmaRagDoll</dt><dd></dd><dt>PHYS_Pawn</dt><dd></dd></dl>
<h3><a name="0.3.12"></a>ERenderStyle</h3>
<p>Style for rendering sprites, meshes.</p>
<dl><dt>STY_None</dt><dd></dd><dt>STY_Normal</dt><dd></dd><dt>STY_Masked</dt><dd></dd><dt>STY_Translucent</dt><dd></dd><dt>STY_Modulated</dt><dd></dd><dt>STY_Alpha</dt><dd></dd><dt>STY_Additive</dt><dd></dd><dt>STY_Subtractive</dt><dd></dd><dt>STY_Particle</dt><dd></dd><dt>STY_AlphaZ</dt><dd></dd></dl>
<h3><a name="0.3.13"></a>ESoundOcclusion</h3>
<p>Sound occlusion</p>
<dl><dt>OCCLUSION_Default</dt><dd></dd><dt>OCCLUSION_None</dt><dd>Objects between this Actor and Player do not affect sound</dd><dt>OCCLUSION_BSP</dt><dd>BSP between this Actor and Player affects sounds</dd><dt>OCCLUSION_StaticMeshes</dt><dd>StaticMeshes between Actor and Player affects sounds</dd></dl>
<h3><a name="0.3.14"></a>ESoundSlot</h3>
<dl><dt>SLOT_None</dt><dd>Generic sound slot, any sound played in this slot should play, even if sound is already playing. All other slots are one sound at a time.</dd><dt>SLOT_Misc</dt><dd>Misc. sounds</dd><dt>SLOT_Pain</dt><dd>Pain sounds</dd><dt>SLOT_Interact</dt><dd>Interaction with the world sounds</dd><dt>SLOT_Ambient</dt><dd>Ambient Noise</dd><dt>SLOT_Talk</dt><dd>Talking</dd><dt>SLOT_Interface</dt><dd>User Interface sounds</dd></dl>
<h3><a name="0.3.15"></a>ETravelType</h3>
<p>Travelling from server to server.</p>
<dl><dt>TRAVEL_Absolute</dt><dd>Travel to absolute URL</dd><dt>TRAVEL_Partial</dt><dd>Partial travel (carry name, reset server) ?</dd><dt>TRAVEL_Relative</dt><dd>Relative URL</dd></dl>
<h2><a name="0.4"></a>Structures</h2>
<h3><a name="0.4.1"></a>ActorRenderDataPtr</h3>
<dl><dt>int Ptr</dt><dd></dd></dl>
<h3><a name="0.4.2"></a>AnimRep</h3>
<p>Animation replication (can be used to replicate channel 0 anims for dumb proxies)</p>
<dl><dt>byte AnimFrame</dt><dd></dd><dt>byte AnimRate</dt><dd>note that with compression, max replicated animrate is 4.0</dd><dt>name AnimSequence</dt><dd></dd><dt>bool bAnimLoop</dt><dd></dd><dt>byte TweenRate</dt><dd>note that with compression, max replicated tweentime is 4 seconds</dd></dl>
<h3><a name="0.4.3"></a>BatchReference</h3>
<dl><dt>int BatchIndex</dt><dd></dd><dt>int ElementIndex</dt><dd></dd></dl>
<h3><a name="0.4.4"></a>EventHandlerMapping</h3>
<h4><a name="0.4.4.1"></a>Actor</h4>
<dl><dt>Name EventName</dt><dd></dd><dt>Name HandledBy</dt><dd></dd></dl>
<h3><a name="0.4.5"></a>KRBVec</h3>
<dl><dt>float X</dt><dd></dd><dt>float Y</dt><dd></dd><dt>float Z</dt><dd></dd></dl>
<h3><a name="0.4.6"></a>KRigidBodyState</h3>
<dl><dt>KRBVec AngVel</dt><dd></dd><dt>KRBVec LinVel</dt><dd></dd><dt>KRBVec Position</dt><dd></dd><dt>Quat Quaternion</dt><dd></dd></dl>
<h3><a name="0.4.7"></a>LightRenderDataPtr</h3>
<dl><dt>int Ptr</dt><dd></dd></dl>
<h3><a name="0.4.8"></a>PointRegion</h3>
<p>Identifies a unique convex volume in the world.</p>
<dl><dt>int iLeaf</dt><dd>Bsp leaf.</dd><dt>zoneinfo Zone</dt><dd>Zone</dd><dt>byte ZoneNumber</dt><dd>Zone Number.</dd></dl>
<h3><a name="0.4.9"></a>ProjectorRenderInfoPtr</h3>
<p>Hack to to fool C++ header generation...</p>
<dl><dt>int Ptr</dt><dd></dd></dl>
<h3><a name="0.4.10"></a>StaticMeshProjectorRenderInfoPtr</h3>
<dl><dt>int Ptr</dt><dd></dd></dl>
<h3><a name="0.4.11"></a>timerStruct</h3>
<dl><dt>byte bLooping</dt><dd></dd><dt>int slotID</dt><dd></dd><dt>float TimerCounter</dt><dd></dd><dt>float TimerRate</dt><dd></dd></dl>
<h2><a name="0.5"></a>Functions</h2>
<dl><dt>AllActors(class&lt;actor&gt; BaseClass, out actor Actor, optional name MatchTag )</dt><dd>Avoid using <code>AllActors()</code> too often as it iterates through the whole actor list and is therefore slow.</dd><dt>AnimBlendParams(int Stage, optional float BlendAlpha, optional float InTime, optional float OutTime, optional name BoneName, optional bool bGlobalPose )</dt><dd></dd><dt>AnimBlendToAlpha(int Stage, float TargetAlpha, float TimeInterval )</dt><dd></dd><dt>bool AnimIsInGroup(int Channel, name GroupName )</dt><dd></dd><dt>bool AttachToBone(actor Attachment, name BoneName )</dt><dd>Attach the specified Attachment actor to the specified BoneName bone of this Actor</dd><dt>AutonomousPhysics(float DeltaSeconds )</dt><dd></dd><dt>BasedActors(class&lt;actor&gt; BaseClass, out actor Actor )</dt><dd>Returns all actors based on the current actor (slow, like AllActors)</dd><dt>BecomeViewTarget( )</dt><dd>Called by PlayerController when this actor becomes its ViewTarget.</dd><dt>BoneRefresh( )</dt><dd>You want to call this when bringing a Skeletal actor into the world to avoid it going into it's refpose for no obvious reason.</dd><dt>bool CanSplash( )</dt><dd></dd><dt>ChildActors(class&lt;actor&gt; BaseClass, out actor Actor )</dt><dd>ChildActors() returns all actors owned by this actor.  Slow like AllActors()</dd><dt>Clock(out float time )</dt><dd>This is called at the beginning of a section of code to be timed. The variable time does not need to be initialized. Call Unclock() with the same variable you passed to Clock() to get the timer results</dd><dt>CollidingActors(class&lt;actor&gt; BaseClass, out actor Actor, float Radius, optional vector Loc )</dt><dd>CollidingActors() returns colliding (<code>bCollideActors==true</code>) actors within a certain radius.</dd><dt>string ConsoleCommand(string Command )</dt><dd>Execute a console command in the context of the current level and game engine.</dd><dt>CopyMaterialsToSkins( )</dt><dd>Native function unique to LOTD, copies the default Materials into the Skins[] override array</dd><dt>DebugClock( )</dt><dd></dd><dt>DebugUnclock( )</dt><dd></dd><dt>bool Destroy( )</dt><dd>Destroy this actor. Returns true if destroyed, false if indestructable.<br /></dd><dt>bool DetachFromBone(actor Attachment )</dt><dd>Remove the specified Actor, from whatever it is attached to.  It is presumed that it would be attached to THIS actor, but that is apparently not a requirement.</dd><dt>DisplayDebug(Canvas Canvas, out float YL, out float YPos )</dt><dd>List important actor variable on canvas.  HUD will call DisplayDebug() on the current ViewTarget when the ShowDebug exec is used.</dd><dt>DoActionableAction(Controller InstigatingController )</dt><dd>Called whenever a player presses the Action button within this actor's ActionableRadius</dd><dt>DrawDebugLine(vector LineStart, vector LineEnd, byte R, byte G, byte B )</dt><dd>SLOW! Use for debugging only!</dd><dt>DynamicActors(class&lt;actor&gt; BaseClass, out actor Actor, optional name MatchTag )</dt><dd>DynamicActors() only iterates through the non-static actors on the list (still relatively slow, but much better than AllActors).  This should be used in most cases and replaces AllActors in many situations</dd><dt>bool EffectIsRelevant(vector SpawnLocation, bool bForceDedicated )</dt><dd>This should be called by effects to see if they should play.  The original game doesn't use it much at all, but you probably should.</dd><dt>EnableChannelNotify(int Channel, int Switch )</dt><dd></dd><dt>Error(coerce string S )</dt><dd>Handle an error and kill this one actor.</dd><dt>bool FastTrace(vector          TraceEnd,     optional vector TraceStart )</dt><dd>Similar to trace, this one returns true if it hits the world geometry, false if it is not long enough. It will pass right through anything that is not set as world geometry.</dd><dt>FilterStateDirty( )</dt><dd></dd><dt>FinishAnim(optional int Channel )</dt><dd>Latent function that will return when all Animation (or within the specified Channel) is completed</dd><dt>FinishInterpolation( )</dt><dd></dd><dt>bool ForceFeedbackSupported(optional bool Enable )</dt><dd>Without parameters this will return the state of Force Feedback support, with a True parameter, it will enable Force Feedback</dd><dt>FreezeAnimAt(float Time, optional int Channel )</dt><dd>Hold an animation on the specified channel at the specified time frame.</dd><dt>string GetActionableMessage(Controller InstigatingController )</dt><dd>Called in any object when a Player is within it's ActionableRadius to determine what to print on the Player's screen to notify them that they can use the object for something</dd><dt>int GetActionablePriority(Controller InstigatingController )</dt><dd>Called in any object when a Player is within it's ActionableRadius to determine what Actor's GetActionableMessage and DoActionableAction functions should be called by the player, if there are multiple Actionable items involved.  Set to -1 to make this Actor non actionable</dd><dt>GetAnimParams(int Channel, out name OutSeqName, out float OutAnimFrame, out float OutAnimRate )</dt><dd>Returns information about the currently playing Animation</dd><dt>coords GetBoneCoords(name BoneName )</dt><dd>Returns the coords of the BoneName bone.</dd><dt>rotator GetBoneRotation(name BoneName, optional int Space )</dt><dd>Returns the rotation of the BoneName bone</dd><dt>bool GetCacheEntry(int Num, out string GUID, out string Filename )</dt><dd>Give this a number, and it will return you the GUID and Filename of that entry in the Cache.  It may be possible to build some kind of Cache manager thing, but I have no idea why.</dd><dt>vector GetCollisionExtent( )</dt><dd>This returns a collision Extent that could be used with Trace, that will give you the size of this actor as the extent, based on CollisionRadius and CollisionHeight</dd><dt>String GetDebugName( )</dt><dd></dd><dt>String GetHumanReadableName( )</dt><dd>Returns the human readable string representation of an object.</dd><dt>String GetItemName(string FullName )</dt><dd></dd><dt>string GetLocalString(optional int Switch,     optional PlayerReplicationInfo RelatedPRI_1,     optional PlayerReplicationInfo RelatedPRI_2 )</dt><dd>Get localized message string associated with this actor.</dd><dt>string GetMapName(string NameEnding, string MapName, int Dir )</dt><dd></dd><dt>string GetMeshName( )</dt><dd></dd><dt>string GetNextInt(string ClassName, int Num )</dt><dd></dd><dt>GetNextIntDesc(string ClassName, int Num, out string Entry, out string Description )</dt><dd>Read from the INT files available</dd><dt>GetNextSkin(string Prefix, string CurrentSkin, int Dir, out string SkinName, out string SkinDesc )</dt><dd></dd><dt>int GetNotifyChannel( )</dt><dd></dd><dt>plane GetRenderBoundingSphere( )</dt><dd></dd><dt>vector GetRootLocation( )</dt><dd></dd><dt>vector GetRootLocationDelta( )</dt><dd></dd><dt>rotator GetRootRotation( )</dt><dd></dd><dt>rotator GetRootRotationDelta( )</dt><dd></dd><dt>float GetSoundDuration(sound Sound )</dt><dd>Returns the duration in seconds of a sound</dd><dt>string GetURLMap( )</dt><dd></dd><dt>bool HasAnim(name Sequence )</dt><dd>Returns true if this actor has an animation with the named Sequence </dd><dt>HurtRadius(float DamageAmount, float DamageRadius, class&lt;DamageType&gt; DamageType, float Momentum, vector HitLocation )</dt><dd>Hurt locally authoritative actors within the radius.</dd><dt>bool IsAnimating(optional int Channel )</dt><dd>returns true if the specified channel is playing an animation</dd><dt>bool IsInPain( )</dt><dd>Return True if this actor is inside a Pain volume</dd><dt>bool IsInVolume(Volume aVolume )</dt><dd>Returns true if the actor is in the specified volume</dd><dt>bool IsTweening(int Channel )</dt><dd>Presumably returns True if the Actor is Tweening on the particular animation channel</dd><dt>KAddBoneLifter(name BoneName, InterpCurve LiftVel, float LateralFriction, InterpCurve Softness )</dt><dd>Note you MUST turn collision off (<code>KSetBlockKarma</code>) before using bone lifters.</dd><dt>KAddImpulse(vector Impulse, vector Position, optional name BoneName )</dt><dd>A position of (0,0,0) applies impulse at COM (ie no angular component).</dd><dt>KDisableCollision(actor Other )</dt><dd>Turn off Karma collision for this actor to the specified other actor</dd><dt>KDrawRigidBodyState(KRigidBodyState RBState, bool AltColour )</dt><dd>SLOW! Use for debugging only!</dd><dt>KEnableCollision(actor Other )</dt><dd>Turns on Karma collision for this actor to the specified other actor</dd><dt>KFreezeRagdoll( )</dt><dd>Halt a Karma Ragdoll</dd><dt>float KGetActorGravScale( )</dt><dd>Returns the KParams.KGravScale</dd><dt>KGetCOMOffset(out vector offset )</dt><dd>Get the offset of actor's Center of Mass</dd><dt>KGetCOMPosition(out vector pos )</dt><dd>Get actual position of actors Center of Mass in world space</dd><dt>KGetDampingProps(out float lindamp, out float angdamp )</dt><dd>Return the Linear damping and Angular damping</dd><dt>float KGetFriction( )</dt><dd>Return the Karma Friction</dd><dt>float KGetImpactThreshold( )</dt><dd>Return Karma ImpactThreshold</dd><dt>KGetInertiaTensor(out vector it1, out vector it2 )</dt><dd>Return Karma Inertia Tensor</dd><dt>float KGetMass( )</dt><dd>Return Karma Mass</dd><dt>quat KGetRBQuaternion( )</dt><dd></dd><dt>float KGetRestitution( )</dt><dd>Return Karma Restitution (bounciness)</dd><dt>KGetRigidBodyState(out KRigidBodyState RBstate )</dt><dd>Return Karma Rigid Body State</dd><dt>float KGetSkelMass( )</dt><dd>Return Karma SKeletal Mass (where is this set?)</dd><dt>bool KIsAwake( )</dt><dd>Returns true if we are currently simulating</dd><dt>bool KIsRagdollAvailable( )</dt><dd>Returns true if there is a ragdoll available (what are these conditions?)</dd><dt>KMakeRagdollAvailable( )</dt><dd>Make a Ragdoll available (explain?)</dd><dt>KRBVec KRBVecFromVector(vector v )</dt><dd></dd><dt>vector KRBVecToVector(KRBVec RBvec )</dt><dd></dd><dt>KRemoveAllBoneLifters( )</dt><dd></dd><dt>KRemoveLifterFromBone(name BoneName )</dt><dd></dd><dt>KSetActorGravScale(float ActorGravScale )</dt><dd>Set Karma Gravity Scale</dd><dt>KSetBlockKarma(bool newBlock )</dt><dd>Set to Block karma objects</dd><dt>KSetCOMOffset(vector offset )</dt><dd>Set offset of Center of Mass</dd><dt>KSetDampingProps(float lindamp, float angdamp )</dt><dd>Set Linear and Angular karma damping</dd><dt>KSetFriction(float friction )</dt><dd>Set Karma Friction</dd><dt>KSetImpactThreshold(float thresh )</dt><dd>Set Karma ImpactThreshold</dd><dt>KSetInertiaTensor(vector it1, vector it2 )</dt><dd>set Karma Inertia Tensor</dd><dt>KSetMass(float mass )</dt><dd>Set Karma Mass</dd><dt>KSetRestitution(float rest )</dt><dd>Set Karma Restitution (bounciness)</dd><dt>KSetSkelVel(vector Velocity, optional vector AngVelocity, optional bool AddToCurrent )</dt><dd>Set Karma SKeletalVelocity</dd><dt>KSetStayUpright(bool stayUpright, bool allowRotate )</dt><dd>Set Karma StayUpright properties</dd><dt>KSetStayUprightParams(float stiffness, float damping )</dt><dd></dd><dt>KWake( )</dt><dd>Start Karma simulating</dd><dt>LinkMesh(mesh NewMesh, optional bool bKeepAnim )</dt><dd>Link to a new Mesh, optionally keeping the existing Animations or using the new Mesh's animations</dd><dt>LinkSkelAnim(MeshAnimation Anim, optional mesh NewMesh )</dt><dd>Link new Animations, optionally replacing the Mesh (LOTD implements multiple Animation packages per Mesh, there are better functions for dealing with this</dd><dt>LockRootMotion(int Lock )</dt><dd></dd><dt>LoopAnim(name Sequence, optional float Rate, optional float TweenTime, optional int Channel )</dt><dd></dd><dt>MakeNoise(float Loudness )</dt><dd>Inform other creatures that you've made a noise they might hear (they are sent a HearNoise message). (Loudness seems to be 1.0 in most places, is that the max?)</dd><dt>MatchStarting( )</dt><dd>Called when gameplay actually starts.</dd><dt>bool Move(vector Delta )</dt><dd>Move this actor, and everything attached to it, by Delta vector.</dd><dt>bool MoveCacheEntry(string GUID, optional string NewFilename )</dt><dd>Cache management function</dd><dt>bool MoveSmooth(vector Delta )</dt><dd>Like Move(), but will attempt to continue moving by sliding along a wall or up a slight incline/stairs, etc</dd><dt>bool NearSpot(vector Spot )</dt><dd>NearSpot() returns true is spot is within collision cylinder.</dd><dt>Notify( )</dt><dd></dd><dt>OnlyAffectPawns(bool B )</dt><dd></dd><dt>PlayAnim(name Sequence, optional float Rate, optional float TweenTime, optional int Channel )</dt><dd></dd><dt>bool PlayerCanSeeMe( )</dt><dd>PlayerCanSeeMe returns true if any player (server) or the local player (standalone or client) has a line of sight to actor's location.  Note that if you want to use this with an actor that is normally bHidden, you will need to set bHidden=False, and set DrawType=DT_NONE.</dd><dt>PlayFeedbackEffect(String EffectName )</dt><dd>Play a Force Feedback effect</dd><dt>int PlayMusic(string Song, float FadeInTime )</dt><dd>Only used for level music - will be stopped when level changes<br /></dd><dt>PlayOwnedSound(sound               Sound,     optional ESoundSlot Slot,     optional float      Volume,     optional bool       bNoOverride,     optional float      Radius,     optional float      Pitch,     optional bool       Attenuate )</dt><dd>Play a sound effect, but don't propagate to a remote owner (he is playing the sound clientside)</dd><dt>PlaySound(sound               Sound,     optional ESoundSlot Slot,     optional float      Volume,     optional bool       bNoOverride,     optional float      Radius,     optional float      Pitch,     optional bool       Attenuate )</dt><dd>Play a sound effect.</dd><dt>PlayTeleportEffect(bool bOut, bool bSound )</dt><dd>Called when this actor passes through a Teleporter</dd><dt>RadiusActors(class&lt;actor&gt; BaseClass, out actor Actor, float Radius, optional vector Loc )</dt><dd>RadiusActors() returns all actors within a give radius.  Slow like AllActors().  Use CollidingActors() or VisibleCollidingActors() instead if desired actor types are visible (not bHidden) and in the collision hash (<code>bCollideActors</code> is true)</dd><dt>RenderOverlays(Canvas Canvas )</dt><dd>Called by player's hud to request drawing of actor specific overlays onto canvas</dd><dt>ReplaceText(out string Text, string Replace, string With )</dt><dd>Replace string Replace with string With, in string Text, returning result in passed string Text</dd><dt>Reset( )</dt><dd>Reset actor to initial state - used when restarting level without reloading.</dd><dt>SetAnimFrame(float Time, optional int Channel, optional int UnitFlag )</dt><dd>Move to a specific frame of animation, on a specific channel.  If UnitFlag == 0 (default), then Time refers to a percentage of time (0.0 to 1.0). If UnitFlag == 1, then Time refers to a specific Frame number.</dd><dt>SetBase(actor NewBase, optional vector NewFloor )</dt><dd>Set the actor's Base (for attached movement). NewFloor is only valid for Pawns, and is used to set the Floor that they would be walking on if they were PHYS_Walking or PHYS_Spidering.</dd><dt>SetBoneDirection(name BoneName, rotator BoneTurn, optional vector BoneTrans, optional float Alpha, optional int Space )</dt><dd></dd><dt>SetBoneLocation(name BoneName, optional vector BoneTrans, optional float Alpha )</dt><dd></dd><dt>SetBoneRotation(name BoneName, optional rotator BoneTurn, optional int Space, optional float Alpha )</dt><dd></dd><dt>SetBoneScale(int Slot, optional float BoneScale, optional name BoneName )</dt><dd>Adjust the size of a particular bone.  This is used to implement destructable limbs and the Big Head mutator.</dd><dt>SetCollision(optional bool NewColActors, optional bool NewBlockActors, optional bool NewBlockPlayers )</dt><dd>Adjust collision paramters</dd><dt>bool SetCollisionSize(float NewRadius, float NewHeight )</dt><dd>Adjust actor's collisionradius and height</dd><dt>SetDefaultDisplayProperties( )</dt><dd>Reset this actor's Style, bUnlit, and Texture settings to the actor's default.</dd><dt>SetDisplayProperties(ERenderStyle NewStyle, Material NewTexture, bool bLighting )</dt><dd>Set the display properties of an actor. </dd><dt>SetDrawScale(float NewScale )</dt><dd>Adjust the DrawScale of the Actor, 1.0 = normal</dd><dt>SetDrawScale3D(vector NewScale3D )</dt><dd>Adjust the DrawScale3D, (1.0,1.0,1.0) = normal, use negative numbers to mirror</dd><dt>SetDrawType(EDrawType NewDrawType )</dt><dd>Change the actor's DrawType</dd><dt>SetGRI(GameReplicationInfo GRI )</dt><dd></dd><dt>bool SetLocation(vector NewLocation )</dt><dd>This function sets the location of the actor it is called on. It will not work on actors with <code>PHYS_Karma</code> or <code>PHYS_KarmaRagdoll</code>. If the actor cannot occupy the new location because it is colliding with an actor that can block it, it will be placed at the nearest valid location. Note that because Terrain has no "volume" and is just a bent up sheet, the actor may not be moved in this manner when it penetrates terrain.</dd><dt>SetMultiTimer(int slotID, float NewTimerRate, bool bLoop )</dt><dd>Native function apparently specific to LOTD, specifies that this actor's MultiTimer(slotID) function will be called.  Very similar to Timer, but easy to use for multiple things in one actor.</dd><dt>SetOwner(actor NewOwner )</dt><dd>Set this Actor's Owner property</dd><dt>SetPhysics(EPhysics newPhysics )</dt><dd>Changes this Actor's physics type, takes effect on the NEXT tick.</dd><dt>bool SetRelativeLocation(vector NewLocation )</dt><dd>Sets the location relative to this actor's base</dd><dt>bool SetRelativeRotation(rotator NewRotation )</dt><dd>Sets the rotation relative to the actor's base.</dd><dt>bool SetRotation(rotator NewRotation )</dt><dd>This function sets the rotation of the actor it is called on. It will not work on actors with <code>PHYS_Karma</code> or <code>PHYS_KarmaRagdoll</code>.</dd><dt>SetStaticMesh(StaticMesh NewStaticMesh )</dt><dd>Set a new StaticMesh to replace this actor's original setting.</dd><dt>SetTimer(float NewTimerRate, bool bLoop )</dt><dd>Causes <code>Timer()</code> events every <code>NewTimerRate</code> seconds. If <code>bLoop</code> is true, causes <code>Timer()</code> events every <code>NewTimerRate</code> seconds. Otherwise, causes <code>Timer()</code> to be called once in <code>NewTimerRate</code> seconds. <code>SetTimer(0.0, False);</code> stops the timer.</dd><dt>bool ShouldBeHidden( )</dt><dd>Check if class has HideDropDown specifier</dd><dt>Sleep(float Seconds )</dt><dd>Waits for the specified amount of time before returning.<br /></dd><dt>actor Spawn(class&lt;actor&gt;      SpawnClass,     optional actor    SpawnOwner,     optional name     SpawnTag,     optional vector   SpawnLocation,     optional rotator  SpawnRotation )</dt><dd>Spawn an actor. Returns an actor of the specified class, not of class Actor (this is hardcoded in the compiler). <br /><br>Returns None if the actor could not be spawned (either the actor wouldn't fit in the specified location, or the actor list is full). <br /></dd><dt>StartInterpolation( )</dt><dd>When this function is called, the actor will start moving along an interpolation path beginning at Dest</dd><dt>StopAllMusic(float FadeOutTime )</dt><dd>Fade all music out</dd><dt>StopAnimating(optional bool ClearAllButBase )</dt><dd>Halt animation playing for this actor</dd><dt>StopFeedbackEffect(optional String EffectName )</dt><dd>Pass no parameter or "" to stop all.</dd><dt>StopMusic(int SongHandle, float FadeOutTime )</dt><dd>Stop a particular songhandle (returned by PlayMusic)</dd><dt>vector SuggestFallVelocity(vector Destination, vector Start, float MaxZ, float MaxXYSpeed )</dt><dd></dd><dt>bool TouchingActor(Actor A )</dt><dd>Returns true if Actor A is touching this Actor</dd><dt>TouchingActors(class&lt;actor&gt; BaseClass, out actor Actor )</dt><dd>Returns all actors touching the current actor (fast).</dd><dt>Actor Trace(out vector      HitLocation,     out vector      HitNormal,     vector          TraceEnd,     optional vector TraceStart,     optional bool   bTraceActors,     optional vector Extent,     optional out material Material )</dt><dd>This traces a path to find what it collides with first. The line will be traced starting at <code>TraceStart</code> and ending at <code>TraceEnd</code>.<br>If <code>bTraceActors</code> is true, actors will be considered for the tracing, otherwise only pieces of the world (terrain, staticmeshactors, BSP) will be considered for collision.<br>When the trace hits something, <code>HitLocation</code> and <code>HitNormal</code> will be set to contain the location and normal of the impact. If specified, the material of the surface hit can also be returned. If an <code>Extent</code> is specified, you can have the trace have "width." It will have a box of the size specified as a vector (corner to corner) as the "thickness" of the trace. <br /><br>Note that traces are not very fast, so should be avoided or kept to a minimum where possible. <br /></dd><dt>TraceActors(class&lt;actor&gt; BaseClass, out actor Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent )</dt><dd>Return all actors along a traced line.  Reasonably fast (like any trace)</dd><dt>TweenAnim(name Sequence, float Time, optional int Channel )</dt><dd></dd><dt>UnClock(out float time )</dt><dd>This is called at the end of a section of code to be timed passing in the same time variable supplied to Clock.</dd><dt>UntriggerEvent(Name EventName, Actor Other, Pawn EventInstigator )</dt><dd></dd><dt>UpdatePrecacheMaterials( )</dt><dd>Used to add new materials to the Precache specified in Level. Not quite sure why we'd want to do this after the game starts, as that's when the Precaching happens.</dd><dt>UpdatePrecacheStaticMeshes( )</dt><dd>See UpdatePrecacheMaterials</dd><dt>VisibleActors(class&lt;actor&gt; BaseClass, out actor Actor, optional float Radius, optional vector Loc )</dt><dd>Returns all visible (not <code>bHidden</code>) actors within a radius for which a trace from <code>Loc</code> (which defaults to caller's <code>Location</code>) to that actor's <code>Location</code> does not hit the world.<br /></dd><dt>VisibleCollidingActors(class&lt;actor&gt; BaseClass, out actor Actor, float Radius, optional vector Loc, optional bool bIgnoreHidden )</dt><dd>Returns all colliding (<code>bCollideActors==true</code>) actors within a certain radius for which a trace from <code>Loc</code> (which defaults to caller's Location) to that actor's Location does not hit the world.<br /></dd><dt>WaitForNotification(optional float TimeoutInSeconds )</dt><dd>Latent function returns after specified time, or when a Notify() is called</dd></dl>
<h2><a name="0.6"></a>Events</h2>
<dl><dt>AnimEnd(int Channel )</dt><dd>Notification that the current animation has ended. Allows an object to wait for animation completion before proceeding with other activities.</dd><dt>Attach(Actor Other )</dt><dd>Called when this actor is attached to actor Other</dd><dt>BaseChange( )</dt><dd>Called when this actor's Base is changed</dd><dt>BeginEvent( )</dt><dd></dd><dt>BeginPlay( )</dt><dd>Called at the beginning of play</dd><dt>BroadcastLocalizedMessage(class&lt;LocalMessage&gt; MessageClass, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )</dt><dd>Broadcast a localized message to all players.<br /><br>Most message deal with 0 to 2 related PRIs.<br /></dd><dt>Bump(Actor Other )</dt><dd>Called when actor Other bumps this actor</dd><dt>DemoPlaySound(sound               Sound,     optional ESoundSlot Slot,     optional float      Volume,     optional bool       bNoOverride,     optional float      Radius,     optional float      Pitch,     optional bool       Attenuate )</dt><dd></dd><dt>Destroyed( )</dt><dd>Called after this actor's Destroy() function is called</dd><dt>Detach(Actor Other )</dt><dd>Called when this actor is detached from Other</dd><dt>EncroachedBy(actor Other )</dt><dd>Called when Other is encroaching our collision zone</dd><dt>bool EncroachingOn(actor Other )</dt><dd>Called when we are encoraching on Other's collision zone</dd><dt>EndedRotation( )</dt><dd>Called when rotation completes</dd><dt>EndEvent( )</dt><dd></dd><dt>Falling( )</dt><dd>Called when we are falling. Ahhh!!!!!</dd><dt>FellOutOfWorld(eKillZType KillType )</dt><dd>Sets physics to none and destroys the actor.</dd><dt>FinishedInterpolation( )</dt><dd>The implementation in actor only sets <code>bInterpolating</code> to false.</dd><dt>GainedChild(Actor Other )</dt><dd>Called when a child actor is spawned</dd><dt>HitWall(vector HitNormal, actor HitWall )</dt><dd>Called when this actor hits a wall</dd><dt>KApplyForce(out vector Force, out vector Torque )</dt><dd>Event called just before sim to allow user to apply Karma forces</dd><dt>KilledBy(pawn EventInstigator )</dt><dd>Called when this Actor is killed (only appears to be useful for pawns..)</dd><dt>KImpact(actor other, vector pos, vector impactVel, vector impactNorm )</dt><dd>Event called when Karmic actor hits with impact velocity over <code>KImpactThreshold</code>.</dd><dt>KSkelConvulse( )</dt><dd>Event called when a ragdoll convulses (see <a href="karmaparamsskel.html">KarmaParamsSkel</a>)</dd><dt>bool KUpdateState(out KRigidBodyState newState )</dt><dd>This is called from inside C++ physKarma at the appropriate time to update state of Karma rigid body.<br /></dd><dt>KVelDropBelow( )</dt><dd>Event called when karma actor's velocity drops below <code>KVelDropBelowThreshold</code></dd><dt>Landed(vector HitNormal )</dt><dd>Called when we hit the ground</dd><dt>LostChild(Actor Other )</dt><dd>Called when another actor with this actor as its owner is destroyed.</dd><dt>MultiTimer(int slotID )</dt><dd>Called as a result of the SetMultiTimer() function</dd><dt>PhysicsVolumeChange(PhysicsVolume NewVolume )</dt><dd>Called when this actor enters a new Physics Volume</dd><dt>PostBeginPlay( )</dt><dd>Called immediately after gameplay begins.</dd><dt>PostLinearLoad( )</dt><dd></dd><dt>PostLoad( )</dt><dd>Called when a saved game is loaded, to allow actors to fix up anything they might need.</dd><dt>PostNetBeginPlay( )</dt><dd>Called after PostBeginPlay.  On a net client, PostNetBeginPlay() is called after replicated variables have been initialized to their replicated values</dd><dt>PostNetReceive( )</dt><dd>If <code>bNetNotify</code> is True, this event is called when the actor receives an update to any variable through replication.</dd><dt>PostTeleport(Teleporter OutTeleporter )</dt><dd>function called after this Actor has passed through a Teleporter</dd><dt>PostTouch(Actor Other )</dt><dd>Called for PendingTouch actor after physics completes</dd><dt>PreBeginPlay( )</dt><dd>Called immediately before gameplay begins.</dd><dt>bool PreTeleport(Teleporter InTeleporter )</dt><dd>function called before this Actor is going to pass through a Teleporter</dd><dt>RenderTexture(ScriptedTexture Tex )</dt><dd></dd><dt>SetInitialState( )</dt><dd>Called after PostBeginPlay.</dd><dt>Actor SpecialHandling(Pawn Other )</dt><dd></dd><dt>TakeDamage(int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, class&lt;DamageType&gt; DamageType )</dt><dd>Called by anything that wishes to cause this actor Damage</dd><dt>Tick(float DeltaTime )</dt><dd></dd><dt>Timer( )</dt><dd>Called from setting the SetTimer() function</dd><dt>TornOff( )</dt><dd>Networking - called on client when actor is torn off (<code>bTearOff==true</code>)</dd><dt>Touch(Actor Other )</dt><dd>Called when we are touching Actor Other</dd><dt>TravelPostAccept( )</dt><dd>Called when carried into a new level, after AcceptInventory.</dd><dt>TravelPreAccept( )</dt><dd>Called when carried onto a new level, before AcceptInventory.</dd><dt>Trigger(Actor Other, Pawn EventInstigator )</dt><dd>Called when this Actor's "Tag" event is triggered</dd><dt>TriggerEvent(Name eventName, Actor sender, Pawn instigator )</dt><dd>Call this to trigger an event</dd><dt>TriggerEx(Actor sender, Pawn instigator, Name handler )</dt><dd>Called when an Event that this actor handles is called, if bHasHandlers is set</dd><dt>UnTouch(Actor Other )</dt><dd>Called when this actor is no logner touching Other </dd><dt>UnTrigger(Actor Other, Pawn EventInstigator )</dt><dd></dd><dt>UsedBy(Pawn user )</dt><dd>Called if this Actor was touching a Pawn who pressed Use (not used in LOTD in favor of the Actionable system)</dd><dt>ZoneChange(ZoneInfo NewZone )</dt><dd>Called when this actor changes zones</dd></dl>
<script type="text/javascript"><!--
 menuItemAdd("Constants", "#0.1");
menuItemAdd("Properties", "#0.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Actionable", "#0.2.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Advanced", "#0.2.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>BreakNetPlay", "#0.2.3");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Collision", "#0.2.4");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Display", "#0.2.5");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Events", "#0.2.6");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Force", "#0.2.7");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Karma", "#0.2.8");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>LightColor", "#0.2.9");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Lighting", "#0.2.10");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Movement", "#0.2.11");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Object", "#0.2.12");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Sound", "#0.2.13");
menuItemAdd("Enums", "#0.3");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EDetailMode", "#0.3.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EDoubleClickDir", "#0.3.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EDrawType", "#0.3.3");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EFilterState", "#0.3.4");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EForceType", "#0.3.5");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>eKillZType", "#0.3.6");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ELightEffect", "#0.3.7");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ELightType", "#0.3.8");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EMusicTransition", "#0.3.9");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ENetRole", "#0.3.10");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EPhysics", "#0.3.11");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ERenderStyle", "#0.3.12");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ESoundOcclusion", "#0.3.13");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ESoundSlot", "#0.3.14");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ETravelType", "#0.3.15");
menuItemAdd("Structures", "#0.4");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ActorRenderDataPtr", "#0.4.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>AnimRep", "#0.4.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>BatchReference", "#0.4.3");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EventHandlerMapping", "#0.4.4");
menuItemAdd("<tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt>Actor", "#0.4.4.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>KRBVec", "#0.4.5");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>KRigidBodyState", "#0.4.6");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>LightRenderDataPtr", "#0.4.7");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>PointRegion", "#0.4.8");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ProjectorRenderInfoPtr", "#0.4.9");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>StaticMeshProjectorRenderInfoPtr", "#0.4.10");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>timerStruct", "#0.4.11");
menuItemAdd("Functions", "#0.5");
menuItemAdd("Events", "#0.6");
 menuWrite() //--></script></div>
</div>

<div id="footer" class="bar">
	<p><form method="post" action="http://wiki.beyondunreal.com/wiki" enctype="application/x-www-form-urlencoded">
<a href="../index.html">Home Page</a> | <a href="land-of-the-dead.html">Land Of The Dead</a> | <a href="recent-changes.html">Recent Changes</a><br>
Last edited February 20, 2007 5:06 <a href="http://wiki.beyondunreal.com/wiki?action=browse&diff=1&id=Land_Of_The_Dead/Actor">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /><br><br><small><a href="http://wiki.beyondunreal.com/wiki/Land_Of_The_Dead/Actor">Original page</a> &#150; copy created Sat, Jun 23, 2007</small><div></div>
</form>
	</p>
	<p>Mostly Harmless
</p>
</div>
</div><!-- close of "scrolling" div -->

<div id="quickbar">
	<div id="logo"><a href="../index.html"><img src="shared/wikilogo.jpg" width="143" height="100" border="0"></a>
		</div>
	<div class="qbsitename">
		<p>The Unreal Engine Documentation Site</p>
	</div>
	<div class="qbsection">
<p><a href="metatopics.html">Wiki Community</a></p>
<p><a href="category-category.html">Topic Categories</a></p>


<p><a href="recent-changes.html">Recent Changes</a></p>
<p><a href="offline-wiki.html">Offline Wiki</a></p>
</div><div class="qbsection">
<p><a href="unreal-engine.html">Unreal Engine</a></p>
<p><a href="console-commands.html">Console Commands</a></p>
<p><a href="terminology.html">Terminology</a></p>
<p><a href="category-faq.html">FAQs</a></p>
<p><a href="help-desk.html">Help Desk</a></p>
</div><div class="qbsection">
<p><a href="topics-on-mapping.html">Mapping Topics</a></p>
<p><a href="mapping-lessons.html">Mapping Lessons</a></p>
<p><a href="unrealed-3.html">UnrealEd Interface</a></p>
</div><div class="qbsection">
<p><a href="unrealscript.html">UnrealScript Topics</a></p>
<p><a href="unrealscript-lessons.html">UnrealScript Lessons</a></p>
<p><a href="making-mods.html">Making Mods</a></p>
<p><a href="class-tree.html">Class Tree</a></p>
</div><div class="qbsection">
<p><a href="topics-on-modeling.html">Modeling Topics</a></p>
</div><div class="qbsection">
<p><a href="chongqing-page.html">Chongqing Page</a></p>
<p><a href="log-in.html">Log In</a></p></div>
</div>

</body></html>
