<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head lang="en">
	<title>UnrealWiki: Mover</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="stylesheet" type="text/css" media="screen, print"
		href="shared/stylebase.structural.css">	
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/template-default.css">
	<link rel="stylesheet" type="text/css" media="screen"
		href="shared/styles.chblue.css">
	<link rel="stylesheet" type="text/css" media="print"
		href="shared/template-default-print.css">
	<!--[if IE 6]>
			<style>
			/* dirty hack for IE6. */
			#quickbar {
				position: absolute;
				}
			</style>
	<![endif]-->
  <link rel="start" href="http://wiki.beyondunreal.com/">
  <link rel="glossary"  href="http://wiki.beyondunreal.com/wiki/Terminology">
  <link rel="help"  href="http://wiki.beyondunreal.com/wiki/Using_The_Wiki">
<script type="text/javascript" src="shared/dhtml.js"></script>
<script type="text/javascript" src="shared/dhtml-menu.js"></script>
<style type="text/css">#dhtml-menu    { background: #eee; padding: 5px 0px; margin-right: -20px; border: 1px solid #888; border-left: 1px solid #ccc; border-top: 1px solid #ccc;  border-right: 1px solid #888; border-bottom: 1px solid #888 }
#dhtml-menu td { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; padding: 1px 10px; cursor: default }
#dhtml-menu a  { color: #000; font-family: Arial,Helvetica,sans-serif; font-size: 9pt; line-height: 13pt; text-decoration: none }
#dhtml-menu tt { font-family: monospace; font-size: 9pt }
#dhtml-menu-separator { height: 1px; background: red }
#dhtml-menu-anchor { cursor: default }
</style>
<script type="text/javascript" src="shared/expandable.js"></script>
</head>
<body onLoad="menuInit(); document.cookie='page=Mover; path=/'" class="default">
<div id="scrolling"><!-- contains all except the fixed sidebar -->
<div id="topbar"  class="bar">
	<div class="righthalf">
		<input type="text" name="search"  size="14" /> <input type="button" onclick="location.href='../search-error/index.html';" value="search" />
	</div>
	<div class="lefthalf">
		<script type="text/javascript"><!--
			menuAlignRight = false;
		//--></script>
		<span><script type="text/javascript"><!--
 menuWriteAnchor("Quick Navigation") //--></script></span> | <a href="../index.html">Home Page</a> | <a href="recent-changes.html">Recent Changes</a>
	</div>
</div>

<div id="content"><!-- contains the title and article -->
	<h1 class='pagetitle'><a href="http://wiki.beyondunreal.com/wiki?back=Mover">Mover</a></h1>
	<div class="wiki"><div class="classpath"><img src="shared//gameicons/icon-ut2004.png"> <a href="unreal-tournament-2004.html">UT2004</a> :: <a href="actor.html">Actor</a> &gt;&gt; Mover (Package: Engine)<br></div>
<p>A <a href="static-mesh.html">StaticMesh</a> actor that can move between predefined key positions and rotations.</p>
<p>See <a href="mover-ut.html">Mover (UT)</a> for the UT version of this class, which uses a <a href="brush.html">brush</a> instead of a StaticMesh.</p>
<h2><a name="0.1"></a>Properties</h2>
<h3><a name="0.1.1"></a>Main</h3>
<dl><dt>name AntiPortalTag</dt><dd>Tag of attached AntiPortalActor<a href="http://wiki.beyondunreal.com/wiki?action=edit&id=AntiPortalActor&referrerid=Mover">?</a>.</dd><dt>bool bDamageTriggered</dt><dd>Triggered by taking damage  </dd><dt>bool bDynamicLightMover</dt><dd>Apply dynamic lighting to mover.  </dd><dt>bool bOscillatingLoop</dt><dd>Goes from 0 up to X then back down to 0  </dd><dt>byte BrushRaytraceKey</dt><dd>Raytrace the brush here.  </dd><dt>bool bSlave</dt><dd>This brush is a slave.  </dd><dt>bool bToggleDirection</dt><dd>If this Mover is in the RotatingMover state, toggle directions between "Triggerings".</dd><dt>bool bTriggerOnceOnly</dt><dd>Go dormant after first trigger.  </dd><dt>name BumpEvent</dt><dd>Optional event to cause when any valid bumper bumps the mover.  </dd><dt>EBumpType BumpType</dt><dd>Determines what actors can bump-trigger the mover (see declaration for EBumpType below).</dd><dt>bool bUseShortestRotation</dt><dd>Rot by -90 instead of +270, etc.  If end key was 360 and start key is 0, this means it won't have to rotate at all. </dd><dt>bool bUseTriggered</dt><dd>This Mover is Triggered by any Touching player who presses the "Use" key.</dd><dt>float DamageThreshold</dt><dd>Minimum damage to trigger  </dd><dt>float DelayTime</dt><dd>Delay before starting to open  </dd><dt>int EncroachDamage</dt><dd>How much to damage encroached actors.  <em class="em1">Note: This damage is taken by encroached actors before any <tt>MoverEncroachType</tt> reaction is applied.</em></dd><dt>byte KeyNum</dt><dd>Current or destination keyframe.  </dd><dt>EMoverEncroachType MoverEncroachType</dt><dd>Determines how the mover reacts if encroached by another actor (see declaration for EMoverEncroachType below).</dd><dt>EMoverGlideType MoverGlideType</dt><dd>GlideByTime will interpolate between keys by starting out slow, building speed to the halfway point, then slowing down until stopped at the next key.  MoveByTime will interpolate linearly, at a constant speed between keys.</dd><dt>float MoveTime</dt><dd>Time to spend moving between keyframes.  </dd><dt>byte NumKeys</dt><dd>Number of keyframes in total (0-3).  </dd><dt>float OtherTime</dt><dd>TriggerPound's StayOpenTime.</dd><dt>name PlayerBumpEvent</dt><dd>Optional event to cause when the player bumps the mover.  </dd><dt>float StayOpenTime</dt><dd>How long to remain open before closing. <em class="em1">(unless TriggerPound is used, see OtherTime)</em></dd><dt>byte WorldRaytraceKey</dt><dd>Raytrace the world with the brush here.  </dd></dl>
<h3><a name="0.1.2"></a>AI</h3>
<dl><dt>bool bAutoDoor</dt><dd>Automatically setup Door NavigationPoint for this mover  </dd><dt>bool bNoAIRelevance</dt><dd>Don't warn about this mover during path review  </dd></dl>
<h3><a name="0.1.3"></a>MoverEvents</h3>
<dl><dt>name ClosedEvent</dt><dd>Event to cause when closed  </dd><dt>name ClosingEvent</dt><dd>Event to cause when closing  </dd><dt>name LoopEvent</dt><dd>Event to cause when the mover loops  </dd><dt>name OpenedEvent</dt><dd>Event to cause when opened  </dd><dt>name OpeningEvent</dt><dd>Event to cause when opening  </dd></dl>
<h3><a name="0.1.4"></a>MoverSounds</h3>
<dl><dt>sound ClosedSound</dt><dd>When finish closing.  </dd><dt>sound ClosingSound</dt><dd>When start closing.  </dd><dt>sound LoopSound</dt><dd>Played on Loop  </dd><dt>sound MoveAmbientSound</dt><dd>Optional ambient sound when moving.  </dd><dt>sound OpenedSound</dt><dd>When finished opening.  </dd><dt>sound OpeningSound</dt><dd>When start opening.  </dd></dl>
<h3><a name="0.1.5"></a>ReturnGroup</h3>
<dl><dt>bool bIsLeader</dt><dd>This Mover is the leader of a return group of movers.</dd><dt>name ReturnGroup</dt><dd>The return group this mover belongs to. All movers in a return group form a <a href="linked-list.html">linked list</a> of "followers" with each mover's <tt>Leader</tt> pointing to the main mover that should be triggered, bumped, or otherwise activated. The leading mover will tell its <tt>Follower</tt> to open/close whenever it opens or closes itself. The follower in turn will do the same with its own follower, and so on. Make sure only one mover in a return group is flagged as the leader, otherwise you might experience weird stuff including "Infinite Script Recursion" crashes.</dd></dl>
<h3><a name="0.1.6"></a>Hidden</h3>
<dl><dt>KeyRot[24]</dt><dd></dd><dt>KeyPos[24]</dt><dd></dd><dt>array&lt;AntiPortalActor<a href="http://wiki.beyondunreal.com/wiki?action=edit&id=AntiPortalActor&referrerid=Mover">?</a>&gt; AntiPortals</dt><dd></dd><dt>vector BasePos</dt><dd></dd><dt>rotator BaseRot</dt><dd></dd><dt>bool bClientPause</dt><dd></dd><dt>bool bDelaying</dt><dd></dd><dt>bool bOpening</dt><dd></dd><dt>bool bPlayerOnly</dt><dd></dd><dt>int ClientUpdate</dt><dd></dd><dt>Mover Follower</dt><dd>Next mover in the <a href="linked-list.html">linked list</a> of movers belonging to a "return group".</dd><dt>Mover Leader</dt><dd>The primary mover of a "return group".</dd><dt><a href="navigationpoint.html">NavigationPoint</a> myMarker</dt><dd></dd><dt>int numTriggerEvents</dt><dd>Number of times triggered ( count down to untrigger )  </dd><dt>vector OldPos</dt><dd></dd><dt>vector OldPrePivot</dt><dd></dd><dt>rotator OldRot</dt><dd></dd><dt>float PhysRate</dt><dd>Interpolation rate per second.  </dd><dt>byte PrevKeyNum</dt><dd>Previous keyframe.  </dd><dt>vector RealPosition</dt><dd></dd><dt>rotator RealRotation</dt><dd></dd><dt>vector SavedPos</dt><dd></dd><dt>rotator SavedRot</dt><dd></dd><dt><a href="actor.html">Actor</a> SavedTrigger</dt><dd>The Actor that triggered this Mover.</dd><dt>vector SimInterpolate</dt><dd></dd><dt>vector SimOldPos</dt><dd></dd><dt>int SimOldRotPitch</dt><dd></dd><dt>int SimOldRotRoll</dt><dd></dd><dt>int SimOldRotYaw</dt><dd></dd></dl>
<h2><a name="0.2"></a>States</h2>
<dl><dt>OpenTimedMover</dt><dd>Master State for OpenTimed mover states (for movers that open and close between two keys)</dd><dt>StandOpenTimed (extends OpenTimedMover)</dt><dd>Open when stood on, wait, then close.</dd><dt>BumpOpenTimed (extends OpenTimedMover)</dt><dd>Open when bumped, wait, then close.</dd><dt>TriggerOpenTimed (extends OpenTimedMover)</dt><dd>When triggered, open, wait, then close.</dd><dt>LoopMove</dt><dd>When triggered, the mover keeps looping through each of the keys until it gets untriggered.  It will go to the first key after the last key.</dd><dt>TriggerToggle</dt><dd>Toggle between two keys when triggered.</dd><dt>TriggerControl</dt><dd>Start opening immediately when Triggered, begin closing immediately if UnTriggered.  Keep a constant speed, which is based on the MoveTime and the distance between the two keys.</dd><dt>TriggerPound</dt><dd>Can be thought of as acting like the <a href="http://www.twisterdisplay.com/twister/products/easyStriker/index.htm">["Ring The Bell"]</a> carnival attraction.  You "pound" (trigger) it to the top (open key) and it will fall back down. (closed key)  When triggered, begin to Open immediately, and if left alone, Open completely and stay open for OtherTime, not StayOpenTime.  If Untriggered, begin to Close immediately, similar to TriggerControl, and as if the "pound" didn't have enough strength to make to the top and ring the bell.  Unlike TriggerControl which keeps a constant speed, TriggerPound will always use the MoveTime no matter where the Mover is between keys.  So, if Triggered while closing or if UnTriggered in the midst of opening, it will reverse direction and move more slowly to the next key. <em class="em1">(Note: Although the code appears to indicate that a TriggerPound Mover can loop from a fully Closed key after StayOpenTime if more Trigger events have been sent to it than UnTrigger events, it doesn't appear to loop in any situation tested.)</em></dd><dt>TriggerAdvance</dt><dd>(UT200x only?) When Triggered, move toward the Open key.  If UnTriggered, stop moving.</dd><dt>BumpButton</dt><dd>Open when bumped, close when reset.</dd><dt>ConstantLoop</dt><dd>Loop this mover from the moment we begin.  It will go to the first key after the last key.</dd><dt>LeadInOutLooper</dt><dd>A Looping move that goes from 0 to 1 when trigger, loops 1-x then returns to 0 when triggered again.</dd></dl>
<p>(For Scripters: Goes to state LeadInOutLooping when triggered and back to LeadInOutLooper when triggered again.)</p>
<dl><dt>RotatingMover</dt><dd>Uses Movement &rarr; RotationRate.  It rotates when triggered and stops rotating when untriggered.  If bToggleDirection is true, it toggles rotation directions when triggered.</dd></dl>
<h2><a name="0.3"></a>Enums</h2>
<h3><a name="0.3.1"></a>EMoverEncroachType</h3>
<dl><dt>ME_StopWhenEncroach</dt><dd>Stop when the mover hit an actor.</dd><dt>ME_ReturnWhenEncroach</dt><dd>Return to previous position when the mover hit an actor.</dd><dt>ME_CrushWhenEncroach</dt><dd>Crush the poor helpless actor.</dd><dt>ME_IgnoreWhenEncroach</dt><dd>Ignore encroached actors.</dd></dl>
<h3><a name="0.3.2"></a>EMoverGlideType</h3>
<dl><dt>MV_MoveByTime</dt><dd>Move linearly; a constant speed determined by the distance between the keys and the MoveTime.</dd><dt>MV_GlideByTime</dt><dd>Move with smooth acceleration; starting out slow, building speed towards the half way point, then slowing down to a stop at the next key, all within the MoveTime.</dd></dl>
<h3><a name="0.3.3"></a>EBumpType</h3>
<dl><dt>BT_PlayerBump</dt><dd>Can only be bumped by player.</dd><dt>BT_PawnBump</dt><dd>Can be bumped by any <a href="pawn-ut.html">Pawn (UT)</a>.</dd><dt>BT_AnyBump</dt><dd>Can be bumped by any solid actor.</dd></dl>
<h2><a name="0.4"></a>Known Subclasses</h2>
<ul><li><a href="clientmover.html">ClientMover</a></li>
<li><a href="damagetriggermover.html">DamageTriggerMover</a> (custom)</li>
<li><a href="variabletimedmover.html">VariableTimedMover</a> (custom)</li>
</ul>
<h2><a name="0.5"></a>Related Topics</h2>
<ul><li>The <a href="mover-topics.html">Mover Topics</a> page</li>
<li><a href="types-of-trigger.html">Types of Trigger</a> and <a href="event.html">Event</a></li>
</ul>
<h2><a name="0.6"></a>Discussion</h2>
<p><em class="em2">EricBlade:</em> A question.  In Land of the Dead (UE 2226, roughly UT2003 base code, it seems), movers do not replicate properly.  I see there is a bunch of code in Mover, ActionableMover, and DestructableMover to accomodate replication, but it all doesn't seem to work.  Would anyone be interested in taking a look at the code, to see if there's something that can be done to fix it without subclassing and reworking every single mover in the entire codebase? </p>
<p><em class="em2">SuperApe:</em> From what I know, it seems that the bNoDelete setting is the primary reason for proper Mover replication.  This sets the Mover object itself to replicate to all Clients.  So besides the replication block in Mover, you may need to confirm that your engine version is set up to act the same way in that regard.</p>
<p><em class="em2">EricBlade:</em> It turns out, that apparently the actual location/rotation of these movers is not replicated properly.. what the effect is, say you have a door that opens and closes.  If the door's normal state is closed, but you open that door .. then another player logs in, they get the door in the original position on their client, even though it is in the open position on the server.  This gives you a door that appears open, but is actually closed.  Except that it's actually appearing in a third position, the exact opposite of it's normal rotation. It's very weird.</p>
<p><em class="em2">Xian:</em> Well bNoDelete Actors will not be Spawned or Destroyed by the script. It is not responsible for replication DIRECTLY, as is bNetOptional for example, or Role/RemoteRole properties, but apparently the server will delete Server-Side only actors from the Client on game start (not sure if in the PostBeginPlay() session of Engine.GameInfo or earlier. bNoDelete will make the Engine assign the necessary Role/RemoteRole value on Client and Server. Yeah I guess I see what you mean now, you can say it is responsible for replication, but wouldn't say it's the primary reason. You can just as well use bStatic I guess, although apparently Movers don't seem to want it (even though a Brush is bStatic...)</p>
<p>What EricBlade said makes sense, but I am curious how long it takes. I am not that interested in UE2, but in UE1 Timer() is responsible for updating the Client to the Server position, so the first few seconds you join will have a wrong position, although it should be updated later on. Perhaps doing a ClientSetLocation() where you set the position and rotation would be helpful in this case, but I do admit I am too lazy to test, and since I don't have an UE2 dev folder it will be kinda difficult, but I suggest you try it <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<p><em class="em2">SuperApe:</em> Thank you for elaborating the long answer for me. <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<p><em class="em2">EricBlade:</em> Not to bring up an oldish subject, but I didn't notice there were some answers here.  Although the code for Mover says "Movers default to bNoDelete==true", that was not the case in my actual code.  I set bNoDelete=true to the Door movers in the game, and now they appear in the right place when you load the level, but then a few moments later, they either completely disappear, or jump to FSM-only-knows where in the world, apparently on the timer when the position is replicated.  Weeeeird.</p>
<hr class="thin"><p><em class="em2">Sweavo:</em> "Pound Open when triggered.  Pound Closed when untriggered." what on earth does it mean "to pound"?  There is no other reference to pounding in this context on the wiki</p>
<p><em class="em2">Tarquin:</em> yeah, the TriggerPound stuff is a mystery</p>
<p><em class="em2">Xian:</em> Rough skimming tells me that one difference is that there is no <a href="trigger.html">Trigger</a> notification (i.e. calling EndEvent() on the triggering actor) and that the movement loops. Also, you can see that there is no <em class="em1">Stop</em> command after <em class="em1">Open</em>, but there is, however, a <em class="em1">Sleep</em>, and there is a <em class="em1">GoTo</em> command after <em class="em1">Close</em> which calls the <em class="em1">Open</em> label (making a looping session). Although I am really lazy to make a test map (or edit one) to check it, to me it seems like once a Mover with this state is triggered it will cause an Open-Close, Open-Close, Open-Close loop "animation". Considering it belong to UnrealI, I never played it, but I assume one use could be, for example, in a factory, where you have those crushing thingies, f.e. a conveyor belt, and at a point stuff on the belt gets smashed by this, then incinerated or whatever, like a trap-quest, and you'd have to find the right timing to get past it (which explains the name <em class="em1">Pound</em>). Just a thought, but if any of you kind people would test, I might get a confirmation <img alt=":)" src="emoticons/smile.gif" align="middle"> I'm not sure but these are all assumptions after checking the code.</p>
<p><em class="em2">SuperApe:</em> Making a test map to test TriggerPound took all of two minutes.  That and after looking through the code more carefully, I think the best way to consider this Mover state is like that of a carinval attraction: "Ring the Bell" or <a href="http://www.twisterdisplay.com/twister/products/easyStriker/index.htm">["High Striker"]</a>.  This is where you use a large mallet to strike a see-saw to propel a weight up a pole, trying to get it to the top to hit a bell. (thus, "Pound")  When a Mover set to TriggerPound is triggered, it will Open and Close and stop <em class="em1">(like you hit the weight hard enough to go to the top, ring the bell and fall back down)</em>.  If it is Untriggered during this sequence is will begin to Close immediately, like TriggerControl <em class="em1">(also like if you didn't hit the weight hard enough to go to the top of the pole)</em>.  Unlike TriggerControl, TriggerPound will use the same MoveTime and alter it's Speed to travel whatever distance it needs to Open when triggered, or to Close when Untriggered.  IOW, TriggerControl will always move at a constant Speed when Opening or Closing, no matter where it is in that movement between the keys, but TriggerPound will move more slowly to the Open key if it is triggered inbetween the keys, as if you added extra force ("pound") during it's Close movement and you interrupted it's momentum to send it back Open.  TriggerPound uses a method of recording how many Trigger and Untrigger events it recieves.</p>
<p><em class="em2">Xian:</em> Except that it loops (or should according to the code). What is IOW btw ? Well I am sorry if my description was not 100% accurate (except maybe 15%-20%), but it's better that you tested.</p>
<p><em class="em2">SuperApe:</em> A Mover set to TriggerPound does not loop.  It works as I describe above.  It was tested as well as confirmed in the code.  IOW = In Other Words.</p>
<p><em class="em2">Xian:</em> According to this...</p>
<pre class="uscript">Open:
    Disable <span class="uscript-operator">(</span><span class="uscript-name">'Trigger'</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    DoOpen<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    FinishInterpolation<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    FinishedOpening<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>

    <span class="uscript-comment">// If the next key frame is not the last, then</span>
    <span class="uscript-comment">// keep playing back the frames.</span>
    <span class="uscript-comment">//</span>
    <span class="uscript-keyword">if</span> <span class="uscript-operator">(</span>Keynum <span class="uscript-operator">&lt;</span> NumKeys<span class="uscript-number">-1</span><span class="uscript-operator">)</span> <span class="uscript-operator">{</span>
        GotoState <span class="uscript-operator">(</span><span class="uscript-name">'GradualTriggerOpenTimed'</span><span class="uscript-operator">,</span> <span class="uscript-name">'Open'</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    <span class="uscript-operator">}</span>
Close:
    Disable <span class="uscript-operator">(</span><span class="uscript-name">'Trigger'</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    DoClose<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    FinishInterpolation<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    FinishedClosing<span class="uscript-operator">(</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>  <span class="uscript-comment">// throw the current Event, if exists</span>

    <span class="uscript-keyword">if</span> <span class="uscript-operator">(</span>KeyNum <span class="uscript-operator">&gt;</span> <span class="uscript-number">0</span><span class="uscript-operator">)</span>         <span class="uscript-comment">// Still more key-frames to go through</span>
        GotoState <span class="uscript-operator">(</span><span class="uscript-name">'GradualTriggerOpenTimed'</span><span class="uscript-operator">,</span> <span class="uscript-name">'Close'</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>

    Sleep<span class="uscript-operator">(</span>StayOpenTime<span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    <span class="uscript-keyword">if</span><span class="uscript-operator">(</span> bTriggerOnceOnly <span class="uscript-operator">)</span>
    <span class="uscript-operator">{</span>
        AmbientSound <span class="uscript-operator">=</span> <span class="uscript-keyword">None</span><span class="uscript-operator">;</span>
        GotoState<span class="uscript-operator">(</span><span class="uscript-name">''</span><span class="uscript-operator">)</span><span class="uscript-operator">;</span>
    <span class="uscript-operator">}</span>
    <span class="uscript-keyword">if</span><span class="uscript-operator">(</span> SavedTrigger <span class="uscript-operator">!=</span> <span class="uscript-keyword">None</span> <span class="uscript-operator">)</span>
        <span class="uscript-keyword">goto</span> <span class="uscript-name">'Open'</span><span class="uscript-operator">;</span>
<span class="uscript-operator">}</span></pre><p>... it does. At least in theory. As you can see, if the pointer to the SavedTrigger is still there, it loops to Open. Perhaps because it was not triggered using both params (Other and Instigator) it didn't loop in your case, but rest assured, it does loop. <img alt=":)" src="emoticons/smile.gif" align="middle"> There are situations of calling Trigger(None,X) (where X is the Instigator) so I am not surprised if it doesn't happen in all cases.</p>
<p><em class="em2">SuperApe:</em> We're obviously looking at two different versions of code.  In UT200x, a Mover has no "GradualTriggerOpenTimed" state and the only time Trigger() is disabled is after a <tt>bTriggerOnceOnly</tt> check has been made.  <em class="em1">(Incidentally, I see minor differences between the code in UT2003 and UT2004 to accomodate a Reset() function, but it behaves the same way in both.)</em>  I found nothing in the UT200x Mover code that matches the code block you posted.  But regardless, the SavedTrigger is simply allowing the Mover to keep track of multiple Trigger and UnTrigger events sent to it.  When Triggered, SavedTrigger = something, when UnTriggered an equal number of times, SavedTrigger = None.  But that does not seem to allow a fully Closed Mover set to TriggerPound to loop back Open in any case, whether Triggered by a NormalTrigger or via <tt>causeevent</tt> console command (which gives the Mover more Trigger events than Untrigger events).  The description I state above is based on both my interpretation of the UT200x code <em class="em1">and</em> the results of an empirical test of the Mover state in Ued.  It wasn't a guess or theorem.  Didn't you <em class="em1">ask</em> for a confirmation of your intial assesment?</p>
<p><em class="em2">Xian:</em> I did <img alt=":)" src="emoticons/smile.gif" align="middle"> It was pasted from UT. If you'll check the code there you'll see that, as I pasted, the movement gets looped If the SavedTrigger is still referenced (as we both said via triggering). Unfortunately code changed a lot it seems over versions, though I appologize for the confusion.</p>
<p><em class="em2">SuperApe:</em> During a long drive, I had time to think about this and I was bothered by the code that seemed to loop, but didn't in my tests.  Then I remembered the weird thing TriggerPound does with the timing properties: OtherTime is used in place of StayOpenTime with TriggerPound, and StayOpenTime is used as shown above, to sleep after the Mover is Closed all the way.  I'm convinced you're right, it must loop.  Although I am not at a machine I can test this, I'll bet I just didn't wait the default 4 seconds after it Closed to see it loop.  However, it should only loop if the Mover was given more Trigger events than Untrigger events, either by <tt>causeevent</tt> console command, ACTION_TriggerEvent from an AIScript subclass, UseTrigger or the like.  A single NormalTrigger will always give the Mover an equal number of Trigger and Untrigger events, so in that case it would never loop.  I apologize for the confusion.  I think we should be able to refactor this Mover state now.</p>
<p><em class="em2">Xian:</em></p>
<blockquote><p>However, it should only loop if the Mover was given more Trigger events than Untrigger events</p>
</blockquote><p>My point exactly <img alt=":)" src="emoticons/smile.gif" align="middle"> Yeah np, I must have confused you a bit as well with the code above (forgetting to mention it is UT). Well trial and error is the key <img alt=":)" src="emoticons/smile.gif" align="middle"> Hopefully we'll both get to the bottom of this.</p>
<p><em class="em2">SuperApe:</em> Well, whattaya know.  I did more testing, waited extra long times to be sure, but it actually never loops from the fully Closed key.  Whether you give it more Trigger events than UnTrigger events, or not.  Go figure.  I am a little confused by the code now; it seems like it should loop in some instance, but it never appears to do so.  So, I guess my analogy of the "ring the bell" carnival attraction describes the TriggerPound Mover state the best.</p>
<p><em class="em2">Xian:</em> OK double checked both UE1 and UE2 and they are the same in the Close session. That is weird indeed. According to the code as long as one SavedTrigger pointer exists (as you said one extra trigger event, which most likely seems to be caused the easiest by CauseEvent) would cause it to loop. I do trust that you did it properly so I am confused as well now... the code makes my analogy correct but the way it works makes yours correct. I think I'll do some testing in UT once I get some free time... "this is too weird for school" as they say <img alt=":)" src="emoticons/smile.gif" align="middle"></p>
<p><em class="em2">SuperApe:</em> I agree, the way the code makes it look, it is confusing.  On the other hand, to me TriggerPound sounds like the way it is behaving, it sounds like a "ring the bell" attraction.  BTW, it appears that a NormalTrigger is the only way to always get an even number of Trigger and UnTrigger events, but there are several ways a Mover can get just Trigger events along with the <tt>causeevent</tt> console command: ACTION_TriggerEvent, UseTrigger, other Mover Events, etc.</p>
<p><em class="em2">Sweavo:</em> wow, great work guys!  All I can offer is "is bTriggerOnceOnly set?"  hope I'm not insulting you but it's all too common to miss something like that when you're too close to the task!  I'm not able to get to the source at the moment to look for myself...</p>
<p><em class="em2">SuperApe:</em> Not sure what you're asking, Sweavo.  Anyway, this page has been refactored in terms of TriggerPound/TriggerControl (and TriggerAdvance), see above descriptions.  We can probably remove this part of the discussion at least, if everyone is satisfied.</p>
<p><em class="em2">Xian:</em> He's right. He means that if bTriggerOnceOnly was set then they won't react to other triggering effects. According to the code, if that is set it leaves that state completely. Would you mind testing with and without that var just to see why the code says one thing and the way it behaves is different?</p>
<p><em class="em2">Sweavo:</em> You are saying "according to the code it should loop, but I don't see it looping"... so I added "the code doesn't loop if bTriggerOnceOnly is set," as Xian also said just there.  Trouble is, I don't see bTriggerOnceOnly in the default properties for Mover or an of its super- or sub-classes.  Weird.</p>
<p><em class="em2">SuperApe:</em> My tests were with the default setting <tt>bTriggerOnceOnly=false</tt>.  <tt>bTriggerOnceOnly=true</tt> does what you'd expect it to: that is, Trigger (and Untrigger, if Untriggered) once and immediately go to a dormant state no matter what Mover state you're using.  Tests confirmed this.</p>
<p><em class="em2">Sweavo:</em> OK so that's a blind alley then.  As another aside I wonder why that default doesn't show up in my uscript refernece source tree.</p>
<p><em class="em2">SuperApe:</em> Booleans are false by default.  There's no need to declare that in defaultproperties.</p>
<p><em class="em2">Mychaeel:</em> ...unless, of course, you're overriding the default inherited from some superclass (or making sure that you don't accidentally inherit some default other than <code>false</code>).</p>
<p><em class="em2">Xian:</em> Unfortunately this is not the case since this is the parent/base class.</p>
<hr class="thin"><p><a href="category-class-ut2003.html">Category Class (UT2003)</a></p>
<p><a href="category-class-ut2004.html">Category Class (UT2004)</a></p>
<script type="text/javascript"><!--
 menuItemAdd("Properties", "#0.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Main", "#0.1.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>AI", "#0.1.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>MoverEvents", "#0.1.3");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>MoverSounds", "#0.1.4");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>ReturnGroup", "#0.1.5");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>Hidden", "#0.1.6");
menuItemAdd("States", "#0.2");
menuItemAdd("Enums", "#0.3");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EMoverEncroachType", "#0.3.1");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EMoverGlideType", "#0.3.2");
menuItemAdd("<tt>&nbsp;&nbsp;</tt>EBumpType", "#0.3.3");
menuItemAdd("Known Subclasses", "#0.4");
menuItemAdd("Related Topics", "#0.5");
menuItemAdd("Discussion", "#0.6");
 menuWrite() //--></script></div>
</div>

<div id="footer" class="bar">
	<p>
<a href="../index.html">Home Page</a> | <a href="recent-changes.html">Recent Changes</a><br>
Last edited July 25, 2006 14:18 <a href="http://wiki.beyondunreal.com/wiki?action=browse&diff=1&id=Mover">(diff)</a><br>Search: <input type="text" name="search"  size="14" /><input type="button" onclick="location.href='../search-error/index.html';" value="search" /><br><br><small><a href="http://wiki.beyondunreal.com/wiki/Mover">Original page</a> &#150; copy created Sat, Jun 23, 2007</small><div></div>

	</p>
	<p>Gah - a solution with more questions. (EntropicLqd)
</p>
</div>
</div><!-- close of "scrolling" div -->

<div id="quickbar">
	<div id="logo"><a href="../index.html"><img src="shared/wikilogo.jpg" width="143" height="100" border="0"></a>
		</div>
	<div class="qbsitename">
		<p>The Unreal Engine Documentation Site</p>
	</div>
	<div class="qbsection">
<p><a href="metatopics.html">Wiki Community</a></p>
<p><a href="category-category.html">Topic Categories</a></p>


<p><a href="recent-changes.html">Recent Changes</a></p>
<p><a href="offline-wiki.html">Offline Wiki</a></p>
</div><div class="qbsection">
<p><a href="unreal-engine.html">Unreal Engine</a></p>
<p><a href="console-commands.html">Console Commands</a></p>
<p><a href="terminology.html">Terminology</a></p>
<p><a href="category-faq.html">FAQs</a></p>
<p><a href="help-desk.html">Help Desk</a></p>
</div><div class="qbsection">
<p><a href="topics-on-mapping.html">Mapping Topics</a></p>
<p><a href="mapping-lessons.html">Mapping Lessons</a></p>
<p><a href="unrealed-3.html">UnrealEd Interface</a></p>
</div><div class="qbsection">
<p><a href="unrealscript.html">UnrealScript Topics</a></p>
<p><a href="unrealscript-lessons.html">UnrealScript Lessons</a></p>
<p><a href="making-mods.html">Making Mods</a></p>
<p><a href="class-tree.html">Class Tree</a></p>
</div><div class="qbsection">
<p><a href="topics-on-modeling.html">Modeling Topics</a></p>
</div><div class="qbsection">
<p><a href="chongqing-page.html">Chongqing Page</a></p>
<p><a href="log-in.html">Log In</a></p></div>
</div>

</body></html>
